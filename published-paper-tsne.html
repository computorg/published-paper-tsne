<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.4">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Laurens van der Maaten">
<meta name="author" content="Geoffrey Hinton">
<meta name="dcterms.date" content="2008-08-11">
<meta name="keywords" content="visualization, dimensionality reduction, manifold learning, embedding algorithms, multidimensional scaling">
<meta name="description" content="This page is a reworking of the original t-SNE article using the Computo template. It aims to help authors submitting to the journal by using some advanced formatting features. We warmly thank the authors of t-SNE and the editor of JMLR for allowing us to use their work to illustrate the Computo spirit.">

<title>Visualizing Data using t-SNE</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="published-paper-tsne_files/libs/clipboard/clipboard.min.js"></script>
<script src="published-paper-tsne_files/libs/quarto-html/quarto.js"></script>
<script src="published-paper-tsne_files/libs/quarto-html/popper.min.js"></script>
<script src="published-paper-tsne_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="published-paper-tsne_files/libs/quarto-html/anchor.min.js"></script>
<link href="published-paper-tsne_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="published-paper-tsne_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="published-paper-tsne_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="published-paper-tsne_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="published-paper-tsne_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="published-paper-tsne_files/libs/quarto-contrib/pseudocode-2.4/pseudocode.min.js"></script>
<link href="published-paper-tsne_files/libs/quarto-contrib/pseudocode-2.4/pseudocode.min.css" rel="stylesheet">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #FFFFFF;
      }

      .quarto-title-block .quarto-title-banner {
        color: #FFFFFF;
background: #034E79;
      }
</style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; Visualizing Data using t-SNE</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p class="subtitle lead">A practical computo example</p>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
            <div>
        <div class="description">
          <p>This page is a reworking of the original t-SNE article using the Computo template. It aims to help authors submitting to the journal by using some advanced formatting features. We warmly thank the authors of t-SNE and the editor of JMLR for allowing us to use their work to illustrate the Computo spirit.</p>
        </div>
      </div>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliations</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://lvdmaaten.github.io/">Laurens van der Maaten</a> <a href="https://orcid.org/0000-0002-1931-6828" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.tilburguniversity.edu/">
                  TiCC, Tilburg University
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://www.cs.toronto.edu/~hinton/">Geoffrey Hinton</a> <a href="https://orcid.org/0000-0002-8063-7209" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://web.cs.toronto.edu/">
                  Department of Computer Science, University of Toronto
                  </a>
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 11, 2008</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">January 28, 2024</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">visualization, dimensionality reduction, manifold learning, embedding algorithms, multidimensional scaling</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <a href="https://github.com/computorg/published-paper-tsne"><img src="https://github.com/computorg/published-paper-tsne/actions/workflows/build.yml/badge.svg" alt="build status"></a>
                    <p class="date"></p>
        <a href="https://github.com/computorg/published-paper-tsne/issues?q=is%3Aopen+is%3Aissue+label%3Areview"><img src="https://img.shields.io/badge/reviews-reports-blue" alt="reviews"></a>
            </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>We present a new technique called “t-SNE” that visualizes high-dimensional data by giving each datapoint a location in a two or three-dimensional map. The technique is a variation of Stochastic Neighbor Embedding hinton:stochastic that is much easier to optimize, and produces significantly better visualizations by reducing the tendency to crowd points together in the center of the map. t-SNE is better than existing techniques at creating a single map that reveals structure at many different scales. This is particularly important for high-dimensional data that lie on several different, but related, low-dimensional manifolds, such as images of objects from multiple classes seen from multiple viewpoints. For visualizing the structure of very large data sets, we show how t-SNE can use random walks on neighborhood graphs to allow the implicit structure of all the data to influence the way in which a subset of the data is displayed. We illustrate the performance of t-SNE on a wide variety of data sets and compare it with many other non-parametric visualization techniques, including Sammon mapping, Isomap, and Locally Linear Embedding. The visualization produced by t-SNE are significantly better than those produced by other techniques on almost all of the data sets. <br></p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#sec-sne" id="toc-sec-sne" class="nav-link" data-scroll-target="#sec-sne"><span class="header-section-number">2</span> Stochastic Neighbor Embedding</a></li>
  <li><a href="#sec-tsne" id="toc-sec-tsne" class="nav-link" data-scroll-target="#sec-tsne"><span class="header-section-number">3</span> t-Distributed Stochastic Neighbor Embedding</a>
  <ul class="collapse">
  <li><a href="#sec-symmetric_sne" id="toc-sec-symmetric_sne" class="nav-link" data-scroll-target="#sec-symmetric_sne"><span class="header-section-number">3.1</span> Symmetric SNE</a></li>
  <li><a href="#sec-crowding" id="toc-sec-crowding" class="nav-link" data-scroll-target="#sec-crowding"><span class="header-section-number">3.2</span> The Crowding Problem</a></li>
  <li><a href="#sec-heavy_tail" id="toc-sec-heavy_tail" class="nav-link" data-scroll-target="#sec-heavy_tail"><span class="header-section-number">3.3</span> Mismatched tails can compensate for mismatched dimensionalities</a></li>
  <li><a href="#sec-optimization_methods_for_tsne" id="toc-sec-optimization_methods_for_tsne" class="nav-link" data-scroll-target="#sec-optimization_methods_for_tsne"><span class="header-section-number">3.4</span> Optimization methods for t-SNE</a></li>
  </ul></li>
  <li><a href="#sec-experiments" id="toc-sec-experiments" class="nav-link" data-scroll-target="#sec-experiments"><span class="header-section-number">4</span> Experiments</a>
  <ul class="collapse">
  <li><a href="#sec-datasets" id="toc-sec-datasets" class="nav-link" data-scroll-target="#sec-datasets"><span class="header-section-number">4.1</span> Data Sets</a></li>
  <li><a href="#sec-experimental_setup" id="toc-sec-experimental_setup" class="nav-link" data-scroll-target="#sec-experimental_setup"><span class="header-section-number">4.2</span> Experimental Setup</a></li>
  <li><a href="#sec-results" id="toc-sec-results" class="nav-link" data-scroll-target="#sec-results"><span class="header-section-number">4.3</span> Results</a></li>
  </ul></li>
  <li><a href="#sec-large-data" id="toc-sec-large-data" class="nav-link" data-scroll-target="#sec-large-data"><span class="header-section-number">5</span> Applying t-SNE to Large Data Sets</a></li>
  <li><a href="#sec-discussion" id="toc-sec-discussion" class="nav-link" data-scroll-target="#sec-discussion"><span class="header-section-number">6</span> Discussion</a>
  <ul class="collapse">
  <li><a href="#sec-comparison" id="toc-sec-comparison" class="nav-link" data-scroll-target="#sec-comparison"><span class="header-section-number">6.1</span> Comparison with Related Techniques</a></li>
  <li><a href="#sec-weakness" id="toc-sec-weakness" class="nav-link" data-scroll-target="#sec-weakness"><span class="header-section-number">6.2</span> Weakness</a></li>
  </ul></li>
  <li><a href="#sec-conclusion" id="toc-sec-conclusion" class="nav-link" data-scroll-target="#sec-conclusion"><span class="header-section-number">7</span> Conclusions</a></li>
  <li><a href="#acknowledgments" id="toc-acknowledgments" class="nav-link" data-scroll-target="#acknowledgments">Acknowledgments</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  
  
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="published-paper-tsne.pdf"><i class="bi bi-file-pdf"></i>PDF (computo)</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Visualization of high-dimensional data is an important problem in many different domains, and deals with data of widely varying dimensionality. Cell nuclei that are relevant to breast cancer, for example, are described by approximately 30 variables <span class="citation" data-cites="street:nuclear">Street, Wolberg, and Mangasarian (<a href="#ref-street:nuclear" role="doc-biblioref">1993</a>)</span>, whereas the pixel intensity vectors used to represent images or the word-count vectors used to represent documents typically have thousands of dimensions. Over the last few decades, a variety of techniques for the visualization of such high-dimensional data have been proposed, many of which are reviewed by <span class="citation" data-cites="ferreira:visual">Ferreira de Oliveira and Levkowitz (<a href="#ref-ferreira:visual" role="doc-biblioref">2003</a>)</span>. Important techniques include iconographic displays such as Chernoff faces <span class="citation" data-cites="chernoff:use">Chernoff (<a href="#ref-chernoff:use" role="doc-biblioref">1973</a>)</span>, pixel-based techniques <span class="citation" data-cites="keim:designing">Keim (<a href="#ref-keim:designing" role="doc-biblioref">2000</a>)</span>, and techniques that represent the dimensions in the data as vertices in a graph <span class="citation" data-cites="battista:algorithms">Di Battista et al. (<a href="#ref-battista:algorithms" role="doc-biblioref">1994</a>)</span>. Most of these techniques simply provide tools to display more than two data dimensions, and leave the interpretation of the data to the human observer. This severely limits the applicability of these techniques to real-world data sets that contain thousands of high-dimensional datapoints.</p>
<p>In contrast to the visualization techniques discussed above, dimensionality reduction methods convert the high-dimensional data set <span class="math inline">\mathcal{X} = {x_1,
x_2, \dots, x_n}</span> into two or three-dimensional data <span class="math inline">\mathcal{Y} = {y_1, y_2,
\dots, y_n}</span> that can be displayed in a scatterplot. In the paper, we refer to the low-dimensional data representation <span class="math inline">\mathcal{Y}</span> as a map, and to the low-dimensional representations <span class="math inline">y_i</span> of individual datapoints as map points. The aim of dimensionality reduction is to preserve as much of the significant structure of the high-dimensional data as possible in the low-dimensional map. Various techniques for this problem have been proposed that differ in the type of structure they preserve. Traditional dimensionality reduction techniques such as Principal Components Analysis <span class="citation" data-cites="hotelling:analysis">Hotelling (<a href="#ref-hotelling:analysis" role="doc-biblioref">1933</a>)</span> and classical multidimensional scaling <span class="citation" data-cites="torgerson:multidimensional">Torgerson (<a href="#ref-torgerson:multidimensional" role="doc-biblioref">1952</a>)</span> are linear techniques that focus on keeping the low-dimensional representations of dissimilar datapoints far apart. For high-dimensional data that lies on or near a low-dimensional, non-linear manifold it is usually more important to keep the low-dimensional representations of very similar datapoints close together, which is typically not possible with a linear mapping.</p>
<p>A large number of nonlinear dimensionality reduction techniques that aim to preserve the local structure of data have been proposed, many of which are reviewed by <span class="citation" data-cites="lee:nonlinear">John A. Lee and Verleysen (<a href="#ref-lee:nonlinear" role="doc-biblioref">2007</a>)</span>. In particular, we mention the following seven techniques: (1) Sammon mapping <span class="citation" data-cites="sammon:nonlinear">Sammon (<a href="#ref-sammon:nonlinear" role="doc-biblioref">1969</a>)</span>, (2) curvilinear components analysis <span class="citation" data-cites="demartines:curvilinear">Demartines and Herault (<a href="#ref-demartines:curvilinear" role="doc-biblioref">1997</a>)</span>, (3) Stochastic Neighbor Embedding <span class="citation" data-cites="hinton:stochastic">Hinton and Roweis (<a href="#ref-hinton:stochastic" role="doc-biblioref">2003</a>)</span>; (4) Isomap <span class="citation" data-cites="tenenbaum:global">Tenenbaum, Silva, and Langford (<a href="#ref-tenenbaum:global" role="doc-biblioref">2000</a>)</span>, (5) Maximum Variance Unfolding <span class="citation" data-cites="weinberger:learning">Kilian Q. Weinberger, Sha, and Saul (<a href="#ref-weinberger:learning" role="doc-biblioref">2004</a>)</span>; (6) Locally Linear Embedding <span class="citation" data-cites="roweis:nonlinear">Roweis and Saul (<a href="#ref-roweis:nonlinear" role="doc-biblioref">2000</a>)</span>, and (7) Laplacian Eigenmaps <span class="citation" data-cites="belkin:laplacian">Belkin and Niyogi (<a href="#ref-belkin:laplacian" role="doc-biblioref">2001</a>)</span>. Despite the strong performance of these techniques on artificial data sets, they are often not very successful at visualizing real, high-dimensional data. In particular, most of the techniques are not capable of retaining both the local and the global structure of the data in a single map. For instance, a recent study reveals that even a semi-supervised variant of MVU is not capable of separating handwritten digits into their natural clusters <span class="citation" data-cites="song:colored">Song et al. (<a href="#ref-song:colored" role="doc-biblioref">2008</a>)</span>.</p>
<p>In this paper, we describe a way of converting a high-dimensional data set into a matrix of pairwise similarities and we introduce a new technique, called “t-SNE”, for visualizing the resulting similarity data. t-SNE is capable of capturing much of the local structure of the high-dimensional data very well, while also revealing global structure such as the presence of clusters at several scales. We illustrate the performance of t-SNE by comparing it to the seven dimensionality reduction techniques mentioned above on five data sets from a variety of domains. Because of space limitations, most of the <span class="math inline">(7+1)\times5=40</span> maps are presented in the supplemental material, but the maps that we present in the paper are sufficient to demonstrate the superiority of t-SNE.</p>
<p>The outline of the paper is as follows. In <a href="#sec-sne" class="quarto-xref">Section&nbsp;2</a>, we outline SNE as presented by <span class="citation" data-cites="hinton:stochastic">Hinton and Roweis (<a href="#ref-hinton:stochastic" role="doc-biblioref">2003</a>)</span>, which forms the basis for t-SNE. In <a href="#sec-tsne" class="quarto-xref">Section&nbsp;3</a>, we present t-SNE, which has two important differences from SNE. In Section <a href="#sec-experiments" class="quarto-xref">Section&nbsp;4</a>, we describe the experimental setup and the results of our experiments. Subsequently, <a href="#sec-large-data" class="quarto-xref">Section&nbsp;5</a> shows how t-SNE can be modified to visualize real-world data sets that contain many more than 10,000 datapoints. The results of our experiments are discussed in more detail in <a href="#sec-discussion" class="quarto-xref">Section&nbsp;6</a>. Our conclusions and suggestions for future work are presented in <a href="#sec-conclusion" class="quarto-xref">Section&nbsp;7</a>.</p>
</section>
<section id="sec-sne" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Stochastic Neighbor Embedding</h1>
<p>Stochastic Neighbor Embedding (SNE) starts by converting the high-dimensional Euclidean distances between datapoints into conditional probabilities that represent similarities.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> The similarity of datapoint <span class="math inline">x_j</span> to datapoint <span class="math inline">x_i</span> is the conditional probabilities, <span class="math inline">p_{j|i}</span>, that <span class="math inline">x_i</span> would pick <span class="math inline">x_j</span> as its neighbor if neighbors were picked in proportion to their probability density under a Gaussian centered at <span class="math inline">x_i</span>. For nearby datapoints, <span class="math inline">p_{j|i}</span> is relatively high, whereas for widely separated datapoints, <span class="math inline">p_{j|i}</span> will be almost infinitesimal (for reasonable values of the variance of the Gaussian, <span class="math inline">\sigma_i</span>). Mathematically, the conditional probability <span class="math inline">p_{j|i}</span> is given by</p>
<p><span id="eq-sne_large_space"><span class="math display">
p_{j|i} = \frac{\exp(-\|x_i - x_j\|^2/(2\sigma_i^2))}{\sum_{k\neq i} \exp(-\|x_i
- x_k\|^2 / 2 \sigma_i^2)}\,.
\tag{1}</span></span></p>
<p>where <span class="math inline">\sigma_i</span> is the variance of the Gaussian that is centered on datapoint <span class="math inline">x_i</span>. The method for determining the value of <span class="math inline">\sigma_i</span> is presented later in this section. Because we are only interested in modeling pairwise similarities, we set the value of <span class="math inline">p_{i|i}</span> to zero. For the low-dimensional counterparts <span class="math inline">y_i</span> and <span class="math inline">y_j</span> of the high-dimensional datapoints <span class="math inline">x_i</span> and <span class="math inline">x_j</span>, it is possible to compute a similar conditional probability, which we denote by <span class="math inline">q_{j|i}</span>. We set <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> the variance of the Gaussian that is employed in the computation of the conditional probabilities <span class="math inline">q_{j|i}</span> to <span class="math inline">\frac{1}{\sqrt{2}}</span>. Hence, we model the similarity of a map point <span class="math inline">y_j</span> to map point <span class="math inline">y_i</span> by</p>
<p><span class="math display">
q_{j|i} = \frac{\exp(-\|y_i - y_j\|^2)}{\sum_{k \neq i} \exp(-\|y_i
-y_k\|^2)}\,.
</span></p>
<p>Again, since we are only interested in modeling pairwise similarities, we set <span class="math inline">q_{i|i}=0</span>.</p>
<p>If the map points <span class="math inline">y_i</span> and <span class="math inline">y_j</span> correctly model the similarity between the high-dimensional data-points <span class="math inline">x_i</span> and <span class="math inline">x_j</span>, the conditional probabilities <span class="math inline">p_{j|i}</span> and <span class="math inline">q_{j|i}</span> will be equal. Motivated by this observation, SNE aims to find a low-dimensional data representation that minimizes the mismatch between <span class="math inline">p_{j|i}</span> and <span class="math inline">q_{j|i}</span>. A natural measure of the faithfulness with which <span class="math inline">q_{j|i}</span> models <span class="math inline">p_{j|i}</span> is the Kullback-Leibler divergence (which is in the case equal to the cross-entropy up to an additive constant). SNE minimizes the sum of Kullback-Leibler divergences over all datapoints using a gradient descent method. The cost function <span class="math inline">C</span> is given by</p>
<p><span id="eq-sne_cost_function"><span class="math display">
C = \sum_i KL(P_i\|Q_i) = \sum_i \sum_j p_{j|i} \log
\frac{p_{j|i}}{q_{j|i}}\,,
\tag{2}</span></span></p>
<p>in which <span class="math inline">P_i</span> represents the conditional probability distribution over all other datapoints given datapoint <span class="math inline">x_i</span>, and <span class="math inline">Q_i</span> represents the conditional probability distribution over all other map points given map point <span class="math inline">y_i</span>. Because the Kullback-Liebler divergence is not symmetric, different types of error in the pairwise distances in the low-dimensional map are not weighted equally. In particular, there is a large cost for using widely separated map points to represent nearby datapoints (i.e, for using a small <span class="math inline">q_{j|i}</span> to model a large <span class="math inline">p_{j|i}</span>), but there is only a small cost for using nearby map points to represent widely separated datapoints. This small cost comes from wasting some of the probability mass in the relevant <span class="math inline">Q</span> distributions. In other words, the SNE cost function focuses on retaining the local structure of the data in the map (for reasonable values of the variance of the Gaussian in the high-dimensional space, <span class="math inline">\sigma_i</span>).</p>
<p>The remaining parameter to be selected the variance <span class="math inline">\sigma_i</span> of the Gaussian that is centered over each high-dimensional datapoint, <span class="math inline">x_i</span>. It is not likely that there is a single value of <span class="math inline">\sigma_i</span> that is optimal for all datapoints in the data set because the density of the data is likely to vary. In dense regions, a smaller value of <span class="math inline">\sigma_i</span> is usually more appropriate than in sparser regions. Any particular value of <span class="math inline">\sigma_i</span> induces a probability distribution, <span class="math inline">P_i</span>, over all of the other datapoints. This distribution has an entropy which increases as <span class="math inline">\sigma_i</span> increases. SNE performs a binary search for the value of <span class="math inline">\sigma_i</span> that produces a <span class="math inline">P_i</span> with a fixed perplexity that is specified by the user<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. The perplexity is defined as</p>
<p><span class="math display">
Perp(P_i) = 2^{H(P_i)}\,,
</span></p>
<p>where <span class="math inline">H(P_i)</span> is the Shannon entropy of <span class="math inline">P_i</span> measured in bits</p>
<p><span class="math display">
H(P_i) = - \sum_j p_{j|i} \log_2 p_{j|i}\,.
</span></p>
<p>The perplexity can be interpreted as a smooth measure of the effective number of neighbors. The performance of SNE is fairly robust to changes in the perplexity, and typical values are between 5 and 50.</p>
<p>The minimization of the cost function in <a href="#eq-sne_cost_function" class="quarto-xref">Equation&nbsp;2</a> is performed using a gradient descent method. The gradient has a surprisingly simple form</p>
<p><span class="math display">
\frac{\partial C}{\partial y_i} = 2 \sum_j (p_{j|i} - q_{j|i} + p_{i|j} -
q_{i|j})(y_i - y_j)\,.
</span></p>
<p>Physically, the gradient may be interpreted as the resultant force created by a set of springs between the map point <span class="math inline">y_i</span> and all other map points <span class="math inline">y_j</span>. All springs exert a force along the direction <span class="math inline">(y_i - y_j)</span>. The spring between <span class="math inline">y_i</span> and <span class="math inline">y_j</span> repels or attracts the map points depending on whether the distance between the two in the map is too small or too large to represent the similarities between the two high-dimensional datapoints. The force exerted by the spring between <span class="math inline">y_i</span> and <span class="math inline">y_j</span> is proportional to its length, and also proportional to its stiffness, which is the mismatch <span class="math inline">(p_{j|i} -
q_{j|i} + p_{i|j} + q_{i|j})</span> between the pairwise similarities of the data points.</p>
<p>The gradient descent is initialized by sampling map points randomly from an isotropic Gaussian with small variance that is centered around the origin. In order to speed up the optimization and to avoid poor local minima, a relatively large momentum term is added to the gradient. In other words, the current gradient is added to an exponentially decaying sum of previous gradients in order to determine the changes in the coordinates of the map points at each iteration of the gradient search. Mathematically, the gradient update with a momentum term is given by</p>
<p><span class="math display">
\mathcal{Y}^{(t)} = \mathcal{Y}^{(t-1)} + \eta \frac{\partial C}{\partial
\mathcal{Y}} + \alpha(t) \left( \mathcal{Y}^{(t-1)} - \mathcal{Y}^{(t-2)}\right)\,,
</span></p>
<p>where <span class="math inline">\mathcal{Y}^{(t)}</span> indicates the solution at iteration <span class="math inline">t</span>, <span class="math inline">\eta</span> indicates the learning rate, and <span class="math inline">\alpha(t)</span> represents the momentum at iteration <span class="math inline">t</span>.</p>
<p>In addition, in the early stages of the optimization, Gaussian noise is added to the map points after each iteration. Gradually reducing the variance of this noise performs a type of simulated annealing that helps the optimization to escape from poor local minima in the cost function. If the variance of the noise changes very slowly at the critical point at which the global structure of the map starts to form, SNE tends to find maps with a better global organization. Unfortunately, this requires sensible choices of the initial amount of Gaussian noise and the rate at which it decays. Moreover, these choices interact with the amount of momentum and the step size that are employed in the gradient descent. It is therefore common to run the optimization several times on a data set to find appropriate values for the parameters.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> In this respect, SNE is inferior to methods that allow convex optimization and it would be useful to find an optimization method that gives good results without requiring the extra computation time and parameter choices introduced by the simulated annealing.</p>
</section>
<section id="sec-tsne" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> t-Distributed Stochastic Neighbor Embedding</h1>
<p><a href="#sec-sne" class="quarto-xref">Section&nbsp;2</a> discussed SNE as it was presented by <span class="citation" data-cites="hinton:stochastic">Hinton and Roweis (<a href="#ref-hinton:stochastic" role="doc-biblioref">2003</a>)</span>. Although SNE constructs reasonably good visualizations, it is hampered by a cost function that is difficult to optimize and by a problem we refer to as the “crowding problem.” In this section, we present a new technique called “t-Distributed Stochastic Neighbor Embedding” or “t-SNE” that aims to alleviate these problems. The cost function used by t-SNE differs from the one used by SNE in two ways: (1) it uses a symmetrized version of the SNE cost function with simpler gradients that was briefly introduced by <span class="citation" data-cites="cook:visualizing">Cook et al. (<a href="#ref-cook:visualizing" role="doc-biblioref">2007</a>)</span> and (2) it uses a Student-t distribution rather than a Gaussian to compute the similarity between two points <em>in the low dimensional space</em>. t-SNE employs a heavy-tailed distribution in the low-dimensional space to alleviate both the crowding problem and the optimization problems of SNE.</p>
<p>In this section, we first discuss the symmetric version of SNE (<a href="#sec-symmetric_sne" class="quarto-xref">Section&nbsp;3.1</a>). Subsequently, we discuss the crowding problem (<a href="#sec-crowding" class="quarto-xref">Section&nbsp;3.2</a>), and the use of heavy-tailed distributions to address this problem (<a href="#sec-heavy_tail" class="quarto-xref">Section&nbsp;3.3</a>). We conclude the by describing our approach to the optimization of the t-SNE cost function (<a href="#sec-optimization_methods_for_tsne" class="quarto-xref">Section&nbsp;3.4</a>).</p>
<section id="sec-symmetric_sne" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-symmetric_sne"><span class="header-section-number">3.1</span> Symmetric SNE</h2>
<p>As an alternative to minimizing the sum of the Kullback-Leibler divergences between the conditional probabilities <span class="math inline">p_{j|i}</span> and <span class="math inline">q_{j|i}</span>, it is also possible to minimize a single Kullback-Leibler divergence between a joint probability distribution, <span class="math inline">P</span>, in the high-dimensional space and a joint probability distribution, <span class="math inline">Q</span>, in the low-dimensional space:</p>
<p><span class="math display">
C = KL(P\|Q) = \sum_i \sum_j p_{ij} \log \frac{p_{ij}}{q_{ij}}\,,
</span></p>
<p>where again, we set <span class="math inline">p_{ij}</span> and <span class="math inline">q_{ii}</span> to zero. We refer to this type of SNE as symmetric SNE, because it has the property that <span class="math inline">p_{ij} = p_{ji}</span> and <span class="math inline">q_{ij} = q_{ji}</span> for all <span class="math inline">i, j</span>. In symmetric SNE, the pairwise similarities in the low-dimensional map <span class="math inline">q_{ij}</span> are given by</p>
<p><span id="eq-pairwise_similarities"><span class="math display">
q_{ij} = \frac{\exp(-\|x_i - x_j\|^2)}{\sum_{k\neq l} \exp(-\|x_k -
x_l\|^2)}\,.
\tag{3}</span></span></p>
<p>The obvious way to define the pairwise similarities in the high-dimensional space <span class="math inline">p_{ij}</span> is</p>
<p><span class="math display">
p_{ij} = \frac{\exp(-\|x_i - x_j\|^2/2\sigma^2)}{\sum_{k\neq l} \exp(-\|x_k -
x_l\|^2/2\sigma^2)}\,
</span></p>
<p>but this causes problems when a high-dimensional datapoint <span class="math inline">x_i</span> is an outlier (i.e., all pairwise distances <span class="math inline">\|x_i - x_j\|^2</span> are large for <span class="math inline">x_i</span>). For such an outlier, the values of <span class="math inline">p_{ij}</span> are extremely small for all <span class="math inline">j</span>, so the location of its low-dimensional map point <span class="math inline">y_i</span> has very little effect on the cost function. As a result, the position of the map point is not well determined by the positions of the other map points. We circumvent this problem by defining the joint probabilities <span class="math inline">p_{ij}</span> in the high dimensional space to be symmetrized conditional probabilities, that is, we set <span class="math inline">p_{ij} =
\frac{p_{j|i} + p_{i|j}}{2n}</span>. This ensures that <span class="math inline">\sum_j p_{ij} &gt;
\frac{1}{2n}</span> for all datapoints <span class="math inline">x_i</span>, as a result of which each datapoint <span class="math inline">x_i</span> makes a significant contribution to the cost function. In the low-dimensional space, symmetric SNE simply uses <a href="#eq-pairwise_similarities" class="quarto-xref">Equation&nbsp;3</a>. The main advantage of the symmetric version of SNE is the simpler form of its gradient, which is faster to compute. The gradient of symmetric SNE is fairly similar to that of asymmetric SNE, and is given by</p>
<p><span class="math display">
\frac{\partial C}{\partial y_i} = 4 \sum_j (p_{ij} - q_{ij})(y_i - y_j)\,.
</span></p>
<p>In preliminary experiments, we observed that symmetric SNE seems to produce maps that are just as good as asymmetric SNE, and sometimes even a little better.</p>
</section>
<section id="sec-crowding" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-crowding"><span class="header-section-number">3.2</span> The Crowding Problem</h2>
<p>Consider a set of datapoints that lie on a two-dimensional curved manifold which is approximately linear on a small scale, and which is embedded within a higher-dimensional space. It is possible to model the small pairwise distances between datapoints fairly well in a two-dimensional map, which is often illustrated on toy examples such as the “Swiss roll” data set. Now suppose that the manifold has ten intrinsic dimensions[^dataset] and is embedded within a space of much higher dimensionality. There are several reasons why the pairwise distances in a two-dimensional map cannot faithfully model distances between points on the ten-dimensional manifold. For instance, in ten dimensions, it is possible to have 11 datapoints that are mutually equidistant and there is no way to model this faithfully in a two-dimensional map. A related problem is the very different distribution of pairwise distances in the two spaces. The volume of a sphere centered on datapoint <span class="math inline">i</span> scales as <span class="math inline">r^m</span>, where <span class="math inline">r</span> is the radius and <span class="math inline">m</span> the dimensionality of the sphere. So if the datapoints are approximately uniformly distributed in the region around <span class="math inline">i</span> on the ten-dimensional manifold, we get the following “crowding problem:” the area of the two-dimensional map that is available to accommodate moderately distant datapoints will not be nearly large enough compared with the area available to accommodate nearby datapoints. Hence, if we want to model the small distances accurately in the map, most of the points that are at a moderate distance from datapoint <span class="math inline">i</span> will have to be placed much too far away in the two-dimensional map. In SNE, the spring connecting datapoint <span class="math inline">i</span> to each of these too-distant map points will thus exert a very small attractive force. Although these attractive forces are very small, the very large number of such forces crushes together the points in the center of the map, which prevents gaps from forming between the natural clusters. Note that the crowding problem is not specific to SNE, but that it occurs in other local techniques for multidimensional scaling such as Sammon mapping.</p>
<p>An attempt to address the crowding problem by adding a slight repulsion to all springs was presented by <span class="citation" data-cites="cook:visualizing">Cook et al. (<a href="#ref-cook:visualizing" role="doc-biblioref">2007</a>)</span>. The slight repulsion is created by introducing a uniform background model with a small mixing proportion, <span class="math inline">\rho</span>. So however far apart two map points are, <span class="math inline">q_{ij}</span> can never fall below <span class="math inline">\frac{2\rho}{n(n-1)}</span> (because the uniform background distribution is over <span class="math inline">n(n-1)/2</span> pairs). As a result, for datapoints that are far apart in the high-dimensional space, <span class="math inline">q_{ij}</span> will always be larger than <span class="math inline">p_{ij}</span>, leading to a slight repulsion. This technique is called UNI-SNE and although it usually outperforms standard SNE, the optimization of the UNI-SNE cost function is tedious. The best optimization method known is to start by setting the background mixing proportion to zero (i.e., by performing standard SNE). Once the SNE cost function has been optimized using simulated annealing, the background mixing proportion can be increased to allow some gaps to form between natural clusters as shown by <span class="citation" data-cites="cook:visualizing">Cook et al. (<a href="#ref-cook:visualizing" role="doc-biblioref">2007</a>)</span>. Optimizing the UNI-SNE cost function directly does not work because two map points that are far apart will get almost all of their <span class="math inline">q_{i}</span> from the uniform background. So even if their <span class="math inline">p_{ij}</span> is large, there will be no attractive force between them, because a small change in their separation will have a vanishingly small <em>proportional</em> effect on <span class="math inline">q_{ij}</span>. This means that if two parts of a cluster get separated early on in the optimization, there is no force to pull them back together.</p>
</section>
<section id="sec-heavy_tail" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="sec-heavy_tail"><span class="header-section-number">3.3</span> Mismatched tails can compensate for mismatched dimensionalities</h2>
<p>Since symmetric SNE is actually matching the joint probabilities of pairs of datapoints in the high-dimensional and the low-dimensional spaces rather than their distances, we have a natural way of alleviating the crowing problem that works as follows. In the high-dimensional space, we convert distances into probabilities using a Gaussian distribution. In the low-dimensional map, we can use a probability distribution that has a much heavier tails than a Gaussian to convert distances into probabilities. This allows a moderate distance in the high-dimensional space to be faithfully modeled by a much larger distance in the map and, as a result, it eliminates the unwanted attractive forces between map points that represent moderately dissimilar datapoints.</p>
<p>In t-SNE, we employ a Student <span class="math inline">t</span>-distribution with a single degree of freedom (which is the same as a Cauchy distribution) as the heavy-tailed distribution in the low-dimensional map. Using this distribution, the joint probabilities <span class="math inline">q_{ij}</span> are defined as</p>
<p><span id="eq-joint_probabilities"><span class="math display">
q_{ij} = \frac{(1+\|y_i - y_j\|^2)^{-1}}{\sum_{k \neq l}(1+\|y_k -
y_t\|^2)^{-1}}
\tag{4}</span></span></p>
<p>We use a Student t-distribution with a single degree of freedom, because it has the particularly nice property that <span class="math inline">\left(1+\|y_i - y_j\|^2\right)^{-1}</span> approaches an inverse square law for large pairwise distances <span class="math inline">\|y_i - y_j\|</span> in the low-dimensional map. This makes the map’s representation of joint probabilities (almost) invariant to changes in the scale of the map for map points that are far apart. It also means that large clusters of points that are far apart interact in just the same way as individual points, so the optimization operates in the same way at all but the finest scales. A theoretical justification for our selection of the Student <span class="math inline">t</span>-distribution is that it is closely related to the Gaussian distribution, as the Student <span class="math inline">t</span>-distribution is an infinite mixture of Gaussians. A computationally convenient property is that it is much faster to evaluate the density of a point under a Student <span class="math inline">t</span>-distribution than under a Gaussian because it does not involve an exponential, even though the Student <span class="math inline">t</span>-distribution is equivalent to an infinite mixture of Gaussians with different variances.</p>
<p>The gradient of the Kullback-Leibler divergence between <span class="math inline">P</span> and the Student-<span class="math inline">t</span> based joint probability distribution <span class="math inline">Q</span> (computed using <a href="#eq-joint_probabilities" class="quarto-xref">Equation&nbsp;4</a>) is derived in Appendix A, and is given by</p>
<p><span id="eq-gradient-tsne"><span class="math display">
\frac{\partial C}{\partial y_i} = 4 \sum_j (p_{ij} - q_{ij})(y_i -
y_j)(1+\|y_i - y_j\|^2)^{-1}\,.
\tag{5}</span></span></p>
<div id="fig-gradients" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-gradients-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/gradients.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-gradients-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Gradients of three types of SNE as a function of the pairwise Euclidean distance between two points in the high-dimensional and the pairwise distance between the points in the low-dimensional data representation.
</figcaption>
</figure>
</div>
<p>In <a href="#fig-gradients" class="quarto-xref">Figure&nbsp;1</a>, we show the gradients between the low-dimensional datapoints <span class="math inline">y_i</span> and <span class="math inline">y_j</span> as a function of their pairwise Euclidean distances in the high-dimensional and the low-dimensional space (i.e., as a function of <span class="math inline">\|x_i-x_j\|</span> and <span class="math inline">\|y_i-y_j\|</span>) for the symmetric versions of SNE, UNI-SNE, and t-SNE. In the figures, positive values of the gradient represent an attraction between the low-dimensional datapoints <span class="math inline">y_i</span> and <span class="math inline">y_j</span>, whereas negative values represent a repulsion between the two datapoints. From the figures, we observe two main advantages of the t-SNE gradient over the gradients of SNE and UNI-SNE.</p>
<p>First, the t-SNE gradient strongly repels dissimilar datapoints that are modeled by a small pairwise distance in the low-dimensional representation. SNE has such repulsion as well, but its effect is minimal compared to the strong attractions elsewhere in the gradient (the largest attraction in our graphical representation of the gradient is approximately 19, whereas the largest repulsion is approximately 1). In UNI-SNE, the amount of repulsion between dissimilar datapoints is slightly larger, however, this repulsion is only strong when the pairwise distance between the points in the low-dimensional representation is already large (which is often not the case, since the low-dimensional representation is initialized by sampling from a Gaussian with a very small variance that is centered around the origin).</p>
<p>Second, although t-SNE introduces strong repulsions between dissimilar datapoints that are modeled by small pairwise distances, these repulsions do not go to infinity. In this respect, t-SNE differs from UNI-SNE, in which the strength of the repulsion between very dissimilar datapoints is proportional to their pairwise distance in the low-dimensional map, which may cause dissimilar datapoints to move much too far away from each other.</p>
<p>Taken together, t-SNE puts emphasis on (1) modeling dissimilar datapoints by means of large pairwise distances, and (2) modeling similar datapoints by means of small pairwise distances. Moreover, as a result of these characteristics of the t-SNE cost function (and as a result of the approximate scale invariance of the Student t-distribution), the optimization of the t-SNE cost function is much easier than the optimization of the cost functions of SNE and UNI-SNE. Specifically, t-SNE introduces long-range forces in the low-dimensional map that can pull back together two (clusters of) similar points that get separated early on in the optimization. SNE and UNI-SNE do not have such long-range forces, as a result of which SNE and UNI-SNE need to use simulated annealing to obtain reasonable solutions. Instead, the long-range forces in t-SNE facilitate the identification of good local optima without resorting to simulated annealing</p>
<div class="pseudocode-container" data-alg-title="Algorithm" data-pseudocode-index="1">
<div class="pseudocode">
\begin{algorithm} \caption{Simple version of t-Distributed Stochastic Neighbor Embeding} \begin{algorithmic} \State \textbf{Data}: high-dimensional representation $\mathcal{X} = \{x_1, \dots, x_n\}$ \State cost function parameters: perplexity $Perp$ \State optimization parameters: number of iterations $T$, learning rate $\eta$, momentum $\alpha(t)$ \State \textbf{Result}: low-dimensional data representation $\mathcal{Y}^{(T)} = \{y_1, \dots, y_n\}$ \Procedure{t-sne}{$Perp, T, \eta, \alpha(t)$} \State compute pairwise affinities $p_{j|i}$ with perplexity $Perp$ (using Equation 1) \State set $p_{ij} = \frac{1}{2n} (p_{j|i} + p_{i|j})$ \State sample initial solution $\mathcal{Y}^{(0)} = \{y_1,\dots,y_n\}$ from $\mathcal{N}(0,1e^{-4} I)$ \For{$t = 0$\dots$T$} \State compute low-dimensional affinities $q_{ij}$ (using Equation 4) \State compute gradient $\frac{\partial C}{\partial \mathcal{Y}}$ (using Equation 5) \State et $\mathcal{Y}^{t} = \mathcal{Y}^{t-1} + \eta \frac{\partial C}{\partial \mathcal{Y}} + \alpha(t) \left(\mathcal{Y}^{t-1} - \mathcal{Y}^{t-2}\right)$ \EndFor \EndProcedure \end{algorithmic} \end{algorithm}
</div>
</div>
</section>
<section id="sec-optimization_methods_for_tsne" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="sec-optimization_methods_for_tsne"><span class="header-section-number">3.4</span> Optimization methods for t-SNE</h2>
<p>We start by presenting a relatively simple, gradient descent procedure for optimizing the t-SNE cost function. This simple procedure uses a momentum term to reduce the number of iterations required and it works best if the momentum term is small until the map points have become moderately well organized. Pseudocode for this simple algorithm is presented in Algorithm 1 (FIXME: ref not working). The simple algorithm can be sped up using the adaptive learning rate scheme that is described by <span class="citation" data-cites="jacobs:rates">Jacobs (<a href="#ref-jacobs:rates" role="doc-biblioref">1988</a>)</span>, which gradually increases the learning rate in directions in which the gradient is stable.</p>
<p>Although the simple algorithm produces visualizations that are often much better than those produced by other non-parametric dimensionality reduction techniques, the results can be improved further by using either of two tricks. The first trick, which we call “early compression,” is to force the map points to stay close together at the start of the optimization. When the distances between map points are small, it is easy for clusters to move through one another so it is much easier to explore the space of possible global organizations of the data. Early compression is implemented by adding an additional L2-penalty to the cost function that is proportional to the sum of squared distances of the map points from the origin. The magnitude of this penalty term and the iteration at which it is removed are set by hand, but the behavior is fairly robust across variations in these two additional optimization parameters.</p>
<p>A less obvious way to improve the optimization, which we call “early exaggeration,” is to multiply all of the <span class="math inline">p_{ij}</span>’s by, for example, 4, in the initial stages of the optimization. This means that almost all of the <span class="math inline">q_{ij}</span>’s, which still add up to 1, are much too small to model their corresponding <span class="math inline">p_{ij}</span>’s. As a result, the optimization is encouraged to focus on modeling the large <span class="math inline">p_{ij}</span>’s by fairly large <span class="math inline">q {ij}</span>’s. The effect is that the natural clusters in the data tend to form tight widely separated clusters in the map. This creates a lot of relatively empty space in the map, which makes it much easier for the clusters to move around relative to one another in order to find a good global organization.</p>
<p>In all the visualizations presented in this paper and in the supporting material, we used exactly the same optimization procedure. We used the early exaggeration method with an exaggeration of 4 for the first 50 iterations (note that early exaggeration is not included in the pseudocode in Algorithm 1). The number of gradient descent iterations <span class="math inline">T</span> was set 1000, and the momentum term was set to <span class="math inline">\alpha^{(t)} = 0.5</span> for <span class="math inline">t&lt;250</span> and <span class="math inline">\alpha^{(t)}=0.8</span> for <span class="math inline">t \geq 250</span>. The learning rate <span class="math inline">\eta</span> is initially set to 100 and it is updated after every iteration by means of the adaptive learning rate scheme described by <span class="citation" data-cites="jacobs:rates">Jacobs (<a href="#ref-jacobs:rates" role="doc-biblioref">1988</a>)</span>. A Matlab implementation of the resulting algorithm is available at <a href="https://lvdmaaten.github.io/tsne/" class="uri">https://lvdmaaten.github.io/tsne/</a>.</p>
</section>
</section>
<section id="sec-experiments" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Experiments</h1>
<p>To evaluate t-SNE, we present experiments in which t-SNE is compared to seven other non-parametric techniques for dimensionality reduction. Because of space limitations, in the paper, we only compare t-SNE with: (1) Sammon mapping, (2) Isomap, and (3) LLE. In the supporting material, we also compare t-SNE with: (4) CCA, (5) SNE, (6) MVU, and (7) Laplacian Eigenmaps. We performed experiments on five data sets that represent a variety of application domains. Again, because of space limitations, we restrict ourselves to three data sets in the paper. The results of our experiments on the remaining two data sets are presented in the supplementary material.</p>
<p>In <a href="#sec-datasets" class="quarto-xref">Section&nbsp;4.1</a>, the data sets that we employed in our experiments are introduced. The setup of the experiments is presented in <a href="#sec-experimental_setup" class="quarto-xref">Section&nbsp;4.2</a>. In <a href="#sec-results" class="quarto-xref">Section&nbsp;4.3</a>, we present the results of our experiments.</p>
<section id="sec-datasets" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="sec-datasets"><span class="header-section-number">4.1</span> Data Sets</h2>
<p>The five data sets we employed in our experiments are: (1) the MNIST data set, (2) the Olivetti faces data set, (3) the COIL-20 data set, (4) the word-features data set, and (5) the Netflix data set. We only present results on the first three data sets in this section. The results on the remaining two data sets are presented in the supporting material. The first three data sets are introduced below.</p>
<p>The MNIST data set<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> contains 60,000 grayscale images of handwritten digits. For our experiments, we randomly selected 6,000 of the images for computational reasons. The digit images have <span class="math inline">28 \times
28 = 784</span> pixels (i.e., dimensions). The Olivetti faces data set<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> consists of images of 40 individuals with small variations in viewpoint, large variations in expression, and occasional addition of glasses. The data set consists of 400 images (10 per individual) of size <span class="math inline">92\times 112=10,304</span> pixels, and is labeled according to identity. The COIL-20 data set <span class="citation" data-cites="nene:coil20">Nene, Nayar, and Murase (<a href="#ref-nene:coil20" role="doc-biblioref">1996</a>)</span> contains images of 20 different objects viewed from 72 equally spaced orientations, yielding a total of 1,440 images. The images contain <span class="math inline">32 \times 32 = 1,024</span> pixels.</p>
</section>
<section id="sec-experimental_setup" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="sec-experimental_setup"><span class="header-section-number">4.2</span> Experimental Setup</h2>
<p>In all of our experiments, we start by using PCA to reduce the dimensionality of the data to 30. This speeds up the computation of pairwise distances between the datapoints and suppresses some noise without severely distorting the interpoint distances. We then use each of the dimensionality reduction techniques to convert the 30-dimensional representation to a two-dimensional map and we show the resulting map as a scatterplot. For all of the data sets, there is information about the class of each datapoint, but the class information is only used to select a color and/or symbol for the map points. The class information is not used to determine the spatial coordinates of the map points. The coloring thus provides a way of evaluating how well the map preserves the similarities within each class.</p>
<p>The cost function parameter settings we employed in our experiments are listed in <a href="#tbl-cost-function-parameters" class="quarto-xref">Table&nbsp;1</a>. In the table, <span class="math inline">Perp</span> represents the perplexity of the conditional probability distribution induced by a Gaussian kernel and <span class="math inline">k</span> represents the number of nearest neighbors employed in a neighborhood graph. In the experiments with Isomap and LLE, we only visualize datapoints that correspond to vertices in the largest connected component of the neighborhood graph. <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> For the Sammon mapping optimization, we performed Newton’s method for 500 iterations.</p>
<div id="tbl-cost-function-parameters" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-cost-function-parameters-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Cost function parameter settings for the experiments
</figcaption>
<div aria-describedby="tbl-cost-function-parameters-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th>Technique</th>
<th style="text-align: right;">Cost function parameters</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>t-SNE</td>
<td style="text-align: right;"><span class="math inline">Perp = 40</span></td>
</tr>
<tr class="even">
<td>Sammon mapping</td>
<td style="text-align: right;">none</td>
</tr>
<tr class="odd">
<td>Isomap</td>
<td style="text-align: right;"><span class="math inline">k=12</span></td>
</tr>
<tr class="even">
<td>LLE</td>
<td style="text-align: right;"><span class="math inline">k=12</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section>
<section id="sec-results" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="sec-results"><span class="header-section-number">4.3</span> Results</h2>
<div id="cell-fig-tsne-sammon" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure 2. Visualization by t-SNE and Sammon mapping</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_digits</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn <span class="im">import</span> manifold</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> joblib</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>mem <span class="op">=</span> joblib.Memory(<span class="st">".joblib"</span>, verbose <span class="op">=</span> <span class="dv">0</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>digits <span class="op">=</span> load_digits()</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> digits[<span class="st">"data"</span>]</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> digits[<span class="st">"target"</span>]</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>n_components <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> {</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: <span class="st">"C0"</span>,</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: <span class="st">"C1"</span>,</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: <span class="st">"C2"</span>,</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: <span class="st">"C3"</span>,</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: <span class="st">"C4"</span>,</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="dv">5</span>: <span class="st">"C5"</span>,</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="dv">6</span>: <span class="st">"C6"</span>,</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="dv">7</span>: <span class="st">"C7"</span>,</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    <span class="dv">8</span>: <span class="st">"C8"</span>,</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="dv">9</span>: <span class="st">"C9"</span>,</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(nrows<span class="op">=</span><span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">12</span>))</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="co"># t-SNE manifold learning</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">0</span>]</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>tsne <span class="op">=</span> manifold.TSNE(n_components<span class="op">=</span>n_components, init<span class="op">=</span><span class="st">"pca"</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(tsne.fit_transform)(X)</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label <span class="kw">in</span> np.unique(y):</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span>colors[label], marker<span class="op">=</span><span class="st">"."</span>,</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"t-SNE"</span>)</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a><span class="co"># Sammon mapping</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a><span class="co"># </span><span class="al">FIXME</span><span class="co"> I think Sammon mapping has weights?</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">1</span>]</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>embedding <span class="op">=</span> manifold.MDS(n_components<span class="op">=</span>n_components)</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(embedding.fit_transform)(X)</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label <span class="kw">in</span> np.unique(y):</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span>colors[label], marker<span class="op">=</span><span class="st">"."</span>,</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Sammon mapping"</span>)</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-tsne-sammon" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-tsne-sammon-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="published-paper-tsne_files/figure-html/fig-tsne-sammon-output-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-tsne-sammon-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Visualization by t-SNE and Sammon mapping
</figcaption>
</figure>
</div>
</div>
</div>
<div id="cell-fig-isomap-lle" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure 3. Visualization by Isomap and LLE</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(nrows<span class="op">=</span><span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">12</span>))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># ISOMAP</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">0</span>]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>isomap <span class="op">=</span> manifold.Isomap(n_components<span class="op">=</span>n_components, n_neighbors<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(isomap.fit_transform)(X)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label <span class="kw">in</span> np.unique(y):</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span>colors[label], marker<span class="op">=</span><span class="st">"."</span>,</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Isomap"</span>)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="co"># LLE</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">1</span>]</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>embedding <span class="op">=</span> manifold.LocallyLinearEmbedding(</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    n_components<span class="op">=</span>n_components,</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    n_neighbors<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(embedding.fit_transform)(X)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label <span class="kw">in</span> np.unique(y):</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span>colors[label], marker<span class="op">=</span><span class="st">"."</span>,</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"LLE"</span>)</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-isomap-lle" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-isomap-lle-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="published-paper-tsne_files/figure-html/fig-isomap-lle-output-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-isomap-lle-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Visualization by Isomap and LLE
</figcaption>
</figure>
</div>
</div>
</div>
<div id="cell-fig-olivetti" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure 4. Visualization of the Olivetti faces data set</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># First, load the olivetti datasets</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> fetch_olivetti_faces</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> fetch_olivetti_faces()</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> data[<span class="st">"data"</span>]</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> data[<span class="st">"target"</span>]</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>markers <span class="op">=</span> [<span class="st">"+"</span>, <span class="st">"."</span>, <span class="st">"v"</span>, <span class="st">"^"</span>, <span class="st">"&gt;"</span>, <span class="st">"&lt;"</span>, <span class="st">"d"</span>, <span class="st">"*"</span>]</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">"black"</span>, <span class="st">"blue"</span>, <span class="st">"red"</span>, <span class="st">"pink"</span>]</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(nrows<span class="op">=</span><span class="dv">2</span>, ncols<span class="op">=</span><span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">8</span>))</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co"># t-SNE manifold learning</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>tsne <span class="op">=</span> manifold.TSNE(n_components<span class="op">=</span>n_components, init<span class="op">=</span><span class="st">"pca"</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(tsne.fit_transform)(X)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label, (m, c) <span class="kw">in</span> <span class="bu">zip</span>(np.unique(y), itertools.product(markers, colors)):</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span>m, c<span class="op">=</span>c,</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    s<span class="op">=</span><span class="dv">8</span>,</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"t-SNE"</span>)</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Sammon mapping</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>embedding <span class="op">=</span> manifold.MDS(n_components<span class="op">=</span>n_components)</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(embedding.fit_transform)(X)</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label, (m, c) <span class="kw">in</span> <span class="bu">zip</span>(np.unique(y), itertools.product(markers, colors)):</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span>m, c<span class="op">=</span>c,</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>    s<span class="op">=</span><span class="dv">8</span>,</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Sammon mapping"</span>)</span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a><span class="co"># ISOMAP</span></span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">1</span>, <span class="dv">0</span>]</span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>isomap <span class="op">=</span> manifold.Isomap(n_components<span class="op">=</span>n_components, n_neighbors<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(isomap.fit_transform)(X)</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label, (m, c) <span class="kw">in</span> <span class="bu">zip</span>(np.unique(y), itertools.product(markers, colors)):</span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span>m, c<span class="op">=</span>c,</span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>    s<span class="op">=</span><span class="dv">8</span>,</span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Isomap"</span>)</span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a><span class="co"># LLE</span></span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a>embedding <span class="op">=</span> manifold.LocallyLinearEmbedding(</span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a>    n_components<span class="op">=</span>n_components,</span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a>    n_neighbors<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(embedding.fit_transform)(X)</span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label, (m, c) <span class="kw">in</span> <span class="bu">zip</span>(np.unique(y), itertools.product(markers, colors)):</span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span>m, c<span class="op">=</span>c,</span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a>    s<span class="op">=</span><span class="dv">8</span>,</span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"LLE"</span>)</span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>downloading Olivetti faces from https://ndownloader.figshare.com/files/5976027 to /home/runner/scikit_learn_data</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-olivetti" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-olivetti-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="published-paper-tsne_files/figure-html/fig-olivetti-output-2.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-olivetti-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Visualization of the Olivetti faces data set
</figcaption>
</figure>
</div>
</div>
</div>
<p>In <a href="#fig-tsne-sammon" class="quarto-xref">Figure&nbsp;2</a> and <a href="#fig-isomap-lle" class="quarto-xref">Figure&nbsp;3</a>, we show the results of our experiments with t-SNE, Sammon mapping, Isomap, and LLE on the MNIST data set. The results reveal the strong performance of t-SNE compared to the other techniques. In particular, Sammon mapping constructs a “ball” in which only three classes (representing the digits 0, 1, and 7) are somewhat separated from the other classes. Isomap and LLE produce solutions in which there are large overlaps between the digit classes. In contrast, tSNE constructs a map in which the separation between the digit classes is almost perfect. Moreover, detailed inspection of the t-SNE map reveals that much of the local structure of the data (such as the orientation of the ones) is captured as well. This is illustrated in more detail in <a href="#sec-large-data" class="quarto-xref">Section&nbsp;5</a> (see <a href="#fig-random-walk-tsne" class="quarto-xref">Figure&nbsp;6</a>). The map produced by t-SNE contains some points that are clustered with the wrong class, but most of these points correspond to distorted digits many of which are difficult to identify. <a href="#fig-olivetti" class="quarto-xref">Figure&nbsp;4</a> shows the results of applying t-SNE, Sammon mapping, Isomap, and LLE to the Olivetti faces data set. Again, Isomap and LLE produce solutions that provide little insight into the class structure of the data. The map constructed by Sammon mapping is significantly better, since it models many of the members of each class fairly close together, but none of the classes are clearly separated in the Sammon map. In contrast, t-SNE does a much better job of revealing the natural classes in the data. Some individuals have their ten images split into two clusters, usually because a subset of the images have the head facing in a significantly different direction, or because they have a very different expression or glasses. For these individuals, it is not clear that their ten images form a natural class when using Euclidean distance in pixel space.</p>
<p>Figure 5 shows the results of applying t-SNE, Sammon mapping, Isomap, and LLE to the COIL20 data set. For many of the 20 objects, t-SNE accurately represents the one-dimensional manifold of viewpoints as a closed loop. For objects which look similar from the front and the back, t-SNE distorts the loop so that the images of front and back are mapped to nearby points. For the four types of toy car in the COIL-20 data set (the four aligned “sausages” in the bottom-left of the tSNE map), the four rotation manifolds are aligned by the orientation of the cars to capture the high similarity between different cars at the same orientation. This prevents t-SNE from keeping the four manifolds clearly separate. Figure 5 also reveals that the other three techniques are not nearly as good at cleanly separating the manifolds that correspond to very different objects. In addition, Isomap and LLE only visualize a small number of classes from the COIL-20 data set, because the data set comprises a large number of widely separated submanifolds that give rise to small connected components in the neighborhood graph.</p>
</section>
</section>
<section id="sec-large-data" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Applying t-SNE to Large Data Sets</h1>
<p>Like many other visualization techniques, t-SNE has a computational and memory complexity that is quadratic in the number of datapoints. This makes it infeasible to apply the standard version of t-SNE to data sets that contain many more than, say, 10,000 points. Obviously, it is possible to pick a random subset of the datapoints and display them using t-SNE, but such an approach fails to make use of the information that the undisplayed datapoints provide about the underlying manifolds. Suppose, for example, that A, B, and C are all equidistant in the high-dimensional space. If there are many undisplayed datapoints between A and B and none between A and C, it is much more likely that A and B are part of the same cluster than A and C. This is illustrated in <a href="#fig-random-walk" class="quarto-xref">Figure&nbsp;5</a>. In this section, we show how t-SNE can be modified to display a random subset of the datapoints (so-called landmark points) in a way that uses information from the entire (possibly very large) data set.</p>
<div id="fig-random-walk" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-random-walk-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/random-walk.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-random-walk-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: An illustration of the advantage of the random walk version of t-SNE over a standard landmark approach. The shaded points A, B, and C are three (almost) equidistant landmark points, whereas the non-shaded datapoints are non-landmark points. The arrows represent a directed neighborhood graph where <span class="math inline">k = 3</span>. In a standard landmark approach, the pairwise affinity between A and B is approximately equal to the pairwise affinity between A and C. In the random walk version of t-SNE, the pairwise affinity between A and B is much larger than the pairwise affinity between A and C, and therefore, it reflects the structure of the data much better.
</figcaption>
</figure>
</div>
<p>We start by choosing a desired number of neighbors and creating a neighborhood graph for all of the datapoints. Although this is computationally intensive, it is only done once. Then, for each of the landmark points, we define a random walk starting at that landmark point and terminating as soon as it lands on another landmark point. During a random walk, the probability of choosing an edge emanating from node xi to node x j is proportional to <span class="math inline">e^{-\|x_i−x_j
\|^2}</span> . We define <span class="math inline">p_{j|i}</span> to be the fraction of random walks starting at landmark point <span class="math inline">x_i</span> that terminate at landmark point <span class="math inline">x_j</span> . This has some resemblance to the way Isomap measures pairwise distances between points. However, as in diffusion maps <span class="citation" data-cites="lafon:diffusion">Lafon and Lee (<a href="#ref-lafon:diffusion" role="doc-biblioref">2006</a>)</span>,<span class="citation" data-cites="nadler:diffusion">Nadler et al. (<a href="#ref-nadler:diffusion" role="doc-biblioref">2006</a>)</span>, rather than looking for the shortest path through the neighborhood graph, the random walk-based affinity measure integrates over all paths through the neighborhood graph. As a result, the random walk-based affinity measure is much less sensitive to “short-circuits” <span class="citation" data-cites="lee:nonlinear2005">John Aldo Lee and Verleysen (<a href="#ref-lee:nonlinear2005" role="doc-biblioref">2005</a>)</span>, in which a single noisy datapoint provides a bridge between two regions of dataspace that should be far apart in the map. Similar approaches using random walks have also been successfully applied to, for example, semi-supervised learning <span class="citation" data-cites="jaakola:partially">Szummer and Jaakkola (<a href="#ref-jaakola:partially" role="doc-biblioref">2002</a>)</span>,<span class="citation" data-cites="zhu:semi">Zhu, Ghahramani, and Lafferty (<a href="#ref-zhu:semi" role="doc-biblioref">2003</a>)</span> and image segmentation <span class="citation" data-cites="grady:random">Grady (<a href="#ref-grady:random" role="doc-biblioref">2006</a>)</span>.</p>
<p>The most obvious way to compute the random walk-based similarities <span class="math inline">p_{j|i}</span> is to explicitly perform the random walks on the neighborhood graph, which works very well in practice, given that one can easily perform one million random walks per second. Alternatively, <span class="citation" data-cites="grady:random">Grady (<a href="#ref-grady:random" role="doc-biblioref">2006</a>)</span> presents an analytical solution to compute the pairwise similarities <span class="math inline">p_{j|i}</span> that involves solving a sparse linear system. The analytical solution to compute the similarities <span class="math inline">p_{j|i}</span> is sketched in Appendix B (FIXME). In preliminary experiments, we did not find significant differences between performing the random walks explicitly and the analytical solution. In the experiment we present below, we explicitly performed the random walks because this is computationally less expensive. However, for very large data sets in which the landmark points are very sparse, the analytical solution may be more appropriate.</p>
<div id="fig-random-walk-tsne" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-random-walk-tsne-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<p><img src="figures/random-walk-tSNE.png" class="img-fluid figure-img"></p>
<p>Visualization of 6,000 digits from the MNIST data set produced by the random walk version of t-SNE (employing all 60,000 digit images).</p>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-random-walk-tsne-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: [Note of the editor] Please note that this dataset is too large for the code to be processed through continuous integration. You can find the code to reproduce this plot on <a href="https://github.com/computorg/published-paper-tsne/tree/main/scripts">github</a>
</figcaption>
</figure>
</div>
<p><a href="#fig-random-walk-tsne" class="quarto-xref">Figure&nbsp;6</a> shows the results of an experiment, in which we applied the random walk version of t-SNE to 6,000 randomly selected digits from the MNIST data set, using all 60,000 digits to compute the pairwise affinities <span class="math inline">p_{j|i}</span>. In the experiment, we used a neighborhood graph that was constructed using a value of <span class="math inline">k = 20</span> nearest neighbors.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> The inset of the figure shows the same visualization as a scatterplot in which the colors represent the labels of the digits. In the t-SNE map, all classes are clearly separated and the “continental” sevens form a small separate cluster. Moreover, t-SNE reveals the main dimensions of variation within each class, such as the orientation of the ones, fours, sevens, and nines, or the “loopiness” of the twos. The strong performance of t-SNE is also reflected in the generalization error of nearest neighbor classifiers that are trained on the low-dimensional representation. Whereas the generalization error (measured using 10-fold cross validation) of a 1-nearest neighbor classifier trained on the original 784-dimensional datapoints is 5.75%, the generalization error of a 1-nearest neighbor classifier trained on the two-dimensional data representation produced by t-SNE is only 5.13%. The computational requirements of random walk t-SNE are reasonable: it took only one hour of CPU time to construct the map in <a href="#fig-random-walk-tsne" class="quarto-xref">Figure&nbsp;6</a>.</p>
</section>
<section id="sec-discussion" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Discussion</h1>
<p>The results in the previous two sections (and those in the supplemental material) demonstrate the performance of t-SNE on a wide variety of data sets. In this section, we discuss the differences between t-SNE and other non-parametric techniques (<a href="sec-comparison">6.1</a>), and we also discuss a number of weaknesses and possible improvements of t-SNE (<a href="sec-weakness">6.2</a>).</p>
<section id="sec-comparison" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="sec-comparison"><span class="header-section-number">6.1</span> Comparison with Related Techniques</h2>
<p>Classical scaling <span class="citation" data-cites="torgerson:multidimensional">Torgerson (<a href="#ref-torgerson:multidimensional" role="doc-biblioref">1952</a>)</span>, which is closely related to PCA <span class="citation" data-cites="mardia:multivariate">Mardia and Bibby (<a href="#ref-mardia:multivariate" role="doc-biblioref">1979</a>)</span> <span class="citation" data-cites="williams:connection">Williams (<a href="#ref-williams:connection" role="doc-biblioref">2002</a>)</span>, finds a linear transformation of the data that minimizes the sum of the squared errors between high-dimensional pairwise distances and their low-dimensional representatives. A linear method such as classical scaling is not good at modeling curved manifolds and it focuses on preserving the distances between widely separated datapoints rather than on preserving the distances between nearby datapoints. An important approach that attempts to address the problems of classical scaling is the Sammon mapping <span class="citation" data-cites="sammon:nonlinear">Sammon (<a href="#ref-sammon:nonlinear" role="doc-biblioref">1969</a>)</span> which alters the cost function of classical scaling by dividing the squared error in the representation of each pairwise Euclidean distance by the original Euclidean distance in the high-dimensional space. The resulting cost function is given by</p>
<p><span class="math display">
    C = \frac{1}{\sum_{ij} \|x_i - x_j\|} \sum_{i \neq j} \frac{\left(\|x_i - x_j\| - \|x_i - x_j\|\right)^2}{\|x_i - x_j\|}\,
</span></p>
<p>where the constant outside of the sum is added in order to simplify the derivation of the gradient. The main weakness of the Sammon cost function is that the importance of retaining small pairwise distances in the map is largely dependent on small differences in these pairwise distances. In particular, a small error in the model of two high-dimensional points that are extremely close together results in a large contribution to the cost function. Since all small pairwise distances constitute the local structure of the data, it seems more appropriate to aim to assign approximately equal importance to all small pairwise distances.</p>
<p>In contrast to Sammon mapping, the Gaussian kernel employed in the high-dimensional space by t-SNE defines a soft border between the local and global structure of the data and for pairs of datapoints that are close together relative to the standard deviation of the Gaussian, the importance of modeling their separations is almost independent of the magnitudes of those separations. Moreover, t-SNE determines the local neighborhood size for each datapoint separately based on the local density of the data (by forcing each conditional probability distribution <span class="math inline">P_i</span> to have the same perplexity).</p>
<p>The strong performance of t-SNE compared to Isomap is partly explained by Isomap’s susceptibility to “short-circuiting”. Also, Isomap mainly focuses on modeling large geodesic distances rather than small ones.</p>
<p>The strong performance of t-SNE compared to LLE is mainly due to a basic weakness of LLE: the only thing that prevents all datapoints from collapsing onto a single point is a constraint on the covariance of the low-dimensional representation. In practice, this constraint is often satisfied by placing most of the map points near the center of the map and using a few widely scattered points to create large covariance (see Figure FIXME). For neighborhood graphs that are almost disconnected, the covariance constraint can also be satisfied by a “curdled” map in which there are a few widely separated, collapsed subsets corresponding to the almost disconnected components. Furthermore, neighborhood-graph based techniques (such as Isomap and LLE) are not capable of visualizing data that consists of two or more widely separated submanifolds, because such data does not give rise to a connected neighborhood graph. It is possible to produce a separate map for each connected component, but this loses information about the relative similarities of the separate components.</p>
<p>Like Isomap and LLE, the random walk version of t-SNE employs neighborhood graphs, but it does not suffer from short-circuiting problems because the pairwise similarities between the highdimensional datapoints are computed by integrating over all paths through the neighborhood graph. Because of the diffusion-based interpretation of the conditional probabilities underlying the random walk version of t-SNE, it is useful to compare t-SNE to diffusion maps. Diffusion maps define a “diffusion distance” on the high-dimensional datapoints that is given by</p>
<p><span class="math display">
D^{(t)}(x_i,x_j) = \sqrt{ \sum_{k} \frac{\left(p^{(t)}_{ik} -
p^{(t)}_{jk}\right)^2)}{\psi(x_k)^{(0)}} }\,
</span></p>
<p>where <span class="math inline">p^{(t)}_{ij}</span> represents the probability of a particle traveling from <span class="math inline">x_i</span> to <span class="math inline">x_j</span> in <span class="math inline">t</span> timesteps through a graph on the data with Gaussian emission probabilities. The term <span class="math inline">\psi(x_k)^{(0)}</span> is a measure for the local density of the points, and serves a similar purpose to the fixed perplexity Gaussian kernel that is employed in SNE. The diffusion map is formed by the principal non-trivial eigenvectors of the Markov matrix of the random walks of length <span class="math inline">t</span>. It can be shown that when all <span class="math inline">(n−1)</span> non-trivial eigenvectors are employed, the Euclidean distances in the diffusion map are equal to the diffusion distances in the high-dimensional data representation <span class="citation" data-cites="lafon:diffusion">Lafon and Lee (<a href="#ref-lafon:diffusion" role="doc-biblioref">2006</a>)</span>. Mathematically, diffusion maps minimize</p>
<p><span class="math display">
C = \sum_i \sum_j \left(D^{(t)}(x_i,x_j) - \|y_i-y_j\|\right)^2
</span></p>
<p>As a result, diffusion maps are susceptible to the same problems as classical scaling: they assign much higher importance to modeling the large pairwise diffusion distances than the small ones and as a result, they are not good at retaining the local structure of the data. Moreover, in contrast to the random walk version of t-SNE, diffusion maps do not have a natural way of selecting the length, <span class="math inline">t</span>, of the random walks.</p>
<p>In the supplemental material, we present results that reveal that t-SNE outperforms CCA <span class="citation" data-cites="demartines:curvilinear">Demartines and Herault (<a href="#ref-demartines:curvilinear" role="doc-biblioref">1997</a>)</span>, MVU <span class="citation" data-cites="weinberger:learning">Kilian Q. Weinberger, Sha, and Saul (<a href="#ref-weinberger:learning" role="doc-biblioref">2004</a>)</span>, and Laplacian Eigenmaps <span class="citation" data-cites="belkin:laplacian">Belkin and Niyogi (<a href="#ref-belkin:laplacian" role="doc-biblioref">2001</a>)</span> as well. For CCA and the closely related CDA <span class="citation" data-cites="lee:robust">John Aldo Lee et al. (<a href="#ref-lee:robust" role="doc-biblioref">2000</a>)</span>, these results can be partially explained by the hard border <span class="math inline">\lambda</span> that these techniques define between local and global structure, as opposed to the soft border of t-SNE. Moreover, within the range <span class="math inline">\lambda</span>, CCA suffers from the same weakness as Sammon mapping: it assigns extremely high importance to modeling the distance between two datapoints that are extremely close.</p>
<p>Like t-SNE, MVU <span class="citation" data-cites="weinberger:learning">Kilian Q. Weinberger, Sha, and Saul (<a href="#ref-weinberger:learning" role="doc-biblioref">2004</a>)</span> tries to model all of the small separations well but MVU insists on modeling them perfectly (i.e., it treats them as constraints) and a single erroneous constraint may severely affect the performance of MVU. This can occur when there is a short-circuit between two parts of a curved manifold that are far apart in the intrinsic manifold coordinates. Also, MVU makes no attempt to model longer range structure: It simply pulls the map points as far apart as possible subject to the hard constraints so, unlike t-SNE, it cannot be expected to produce sensible large-scale structure in the map.</p>
<p>For Laplacian Eigenmaps, the poor results relative to t-SNE may be explained by the fact that Laplacian Eigenmaps have the same covariance constraint as LLE, and it is easy to cheat on this constraint.</p>
</section>
<section id="sec-weakness" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="sec-weakness"><span class="header-section-number">6.2</span> Weakness</h2>
<p>Although we have shown that t-SNE comparesfavorably to other techniquesfor data visualization, tSNE has three potential weaknesses: (1) it is unclear how t-SNE performs on general dimensionality reduction tasks, (2) the relatively local nature of t-SNE makes it sensitive to the curse of the intrinsic dimensionality of the data, and (3) t-SNE is not guaranteed to converge to a global optimum of its cost function. Below, we discuss the three weaknesses in more detail.</p>
<ol type="1">
<li><p><em>Dimensionality reduction for other purposes.</em> It is not obvious how t-SNE will perform on the more general task of dimensionality reduction (i.e., when the dimensionality of the data is not reduced to two or three, but to <span class="math inline">d &gt; 3</span> dimensions). To simplify evaluation issues, this paper only considers the use of t-SNE for data visualization. The behavior of t-SNE when reducing data to two or three dimensions cannot readily be extrapolated to <span class="math inline">d &gt; 3</span> dimensions because of the heavy tails of the Student-t distribution. In high-dimensional spaces, the heavy tails comprise a relatively large portion of the probability mass under the Student-t distribution, which might lead to d-dimensional data representations that do not preserve the local structure of the data as well. Hence, for tasks in which the dimensionality of the data needs to be reduced to a dimensionality higher than three, Student t-distributions with more than one degree of freedom10 are likely to be more appropriate.</p></li>
<li><p><em>Curse of intrinsic dimensionality.</em> t-SNE reduces the dimensionality of data mainly based on local properties of the data, which makes t-SNE sensitive to the curse of the intrinsic dimensionality of the data <span class="citation" data-cites="bengio:learning">Bengio (<a href="#ref-bengio:learning" role="doc-biblioref">2009</a>)</span>. In data sets with a high intrinsic dimensionality and an underlying manifold that is highly varying, the local linearity assumption on the manifold that t-SNE implicitly makes (by employing Euclidean distances between near neighbors) may be violated. As a result, t-SNE might be less successful if it is applied on data sets with a very high intrinsic dimensionality (for instance, a recent study by <span class="citation" data-cites="meytlis:face">Meytlis and Sirovich (<a href="#ref-meytlis:face" role="doc-biblioref">2007</a>)</span> estimates the space of images of faces to be constituted of approximately 100 dimensions). Manifold learners such as Isomap and LLE suffer from exactly the same problems (see, e.g., <span class="citation" data-cites="bengio:learning">Bengio (<a href="#ref-bengio:learning" role="doc-biblioref">2009</a>)</span>; <span class="citation" data-cites="vandermaaten:comparison">Van Der Maaten et al. (<a href="#ref-vandermaaten:comparison" role="doc-biblioref">2009</a>)</span> ). A possible way to (partially) address this issue is by performing t-SNE on a data representation obtained from a model that represents the highly varying data manifold efficiently in a number of nonlinear layers such as an autoencoder <span class="citation" data-cites="hinton:reducing">Hinton and Salakhutdinov (<a href="#ref-hinton:reducing" role="doc-biblioref">2006</a>)</span>. Such deep-layer architectures can represent complex nonlinear functions in a much simpler way, and as a result, require fewer datapoints to learn an appropriate solution (as is illustrated for a d-bits parity task by <span class="citation" data-cites="bengio:learning">Bengio (<a href="#ref-bengio:learning" role="doc-biblioref">2009</a>)</span>). Performing t-SNE on a data representation produced by, for example, an autoencoder is likely to improve the quality of the constructed visualizations, because autoencoders can identify highly-varying manifolds better than a local method such as t-SNE. However, the reader should note that it is by definition impossible to fully represent the structure of intrinsically high-dimensional data in two or three dimensions.</p></li>
<li><p><em>Non-convexity of the t-SNE cost function.</em> A nice property of most state-of-the-art dimensionality reduction techniques (such as classical scaling, Isomap, LLE, and diffusion maps) is the convexity of their cost functions. A major weakness of t-SNE is that the cost function is not convex, as a result of which several optimization parameters need to be chosen. The constructed solutions depend on these choices of optimization parameters and may be different each time t-SNE is run from an initial random configuration of map points. We have demonstrated that the same choice of optimization parameters can be used for a variety of different visualization tasks, and we found that the quality of the optima does not vary much from run to run. Therefore, we think that the weakness of the optimization method is insufficient reason to reject t-SNE in favor of methods that lead to convex optimization problems but produce noticeably worse visualizations. A local optimum of a cost function that accurately captures what we want in a visualization is often preferable to the global optimum of a cost function that fails to capture important aspects of what we want. Moreover, the convexity of cost functions can be misleading, because their optimization is often computationally infeasible for large real-world data sets, prompting the use of approximation techniques <span class="citation" data-cites="desilva:global">De Silva and Tenenbaum (<a href="#ref-desilva:global" role="doc-biblioref">2002</a>)</span>; <span class="citation" data-cites="weinberger:graph">Kilian Q. Weinberger et al. (<a href="#ref-weinberger:graph" role="doc-biblioref">2007</a>)</span>. Even for LLE and Laplacian Eigenmaps, the optimization is performed using iterative Arnoldi <span class="citation" data-cites="arnoldi:principle">Arnoldi (<a href="#ref-arnoldi:principle" role="doc-biblioref">1951</a>)</span> or Jacobi-Davidson <span class="citation" data-cites="fokkema:jacobi">Fokkema, Sleijpen, and Van der Vorst (<a href="#ref-fokkema:jacobi" role="doc-biblioref">1998</a>)</span> methods, which may fail to find the global optimum due to convergence problems.</p></li>
</ol>
</section>
</section>
<section id="sec-conclusion" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Conclusions</h1>
<p>The paper presents a new technique for the visualization of similarity data that is capable of retaining the local structure of the data while also revealing some important global structure (such as clusters at multiple scales). Both the computational and the memory complexity of t-SNE are <span class="math inline">\mathcal{O}(n^2)</span>, but we present a landmark approach that makes it possible to successfully visualize large real-world data sets with limited computational demands. Our experiments on a variety of data sets show that t-SNE outperforms existing state-of-the-art techniques for visualizing a variety of real-world data sets. Matlab implementations of both the normal and the random walk version of t-SNE are available for download at <a href="https://lvdmaaten.github.io/tsne/" class="uri">https://lvdmaaten.github.io/tsne/</a>. In future work we plan to investigate the optimization of the number of degrees of freedom of the Student-t distribution used in t-SNE. This may be helpful for dimensionality reduction when the low-dimensional representation has many dimensions. We will also investigate the extension of t-SNE to models in which each high-dimensional datapoint is modeled by several low-dimensional map points as in <span class="citation" data-cites="cook:visualizing">Cook et al. (<a href="#ref-cook:visualizing" role="doc-biblioref">2007</a>)</span>. Also, we aim to develop a parametric version of t-SNE that allows for generalization to held-out test data by using the t-SNE objective function to train a multilayer neural network that provides an explicit mapping to the low-dimensional space</p>
</section>
<section id="acknowledgments" class="level1 unnumbered">
<h1 class="unnumbered">Acknowledgments</h1>
<p>The authors thank Sam Roweis for many helpful discussions, Andriy Mnih for supplying the wordfeatures data set, Ruslan Salakhutdinov for help with the Netflix data set (results for these data sets are presented in the supplemental material), and Guido de Croon for pointing us to the analytical solution of the random walk probabilities.</p>
<p>Laurens van der Maaten is supported by the CATCH-programme of the Dutch Scientific Organization (NWO), project RICH (grant 640.002.401), and cooperates with RACM.<br>
Geoffrey Hinton is a fellow of the Canadian Institute for Advanced Research, and is also supported by grants from NSERC and CFI and gifts from Google and Microsoft.</p>
</section>
<section id="references" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-arnoldi:principle" class="csl-entry" role="listitem">
Arnoldi, Walter Edwin. 1951. <span>“The Principle of Minimized Iterations in the Solution of the Matrix Eigenvalue Problem.”</span> <em>Quarterly of Applied Mathematics</em> 9 (1): 17–29.
</div>
<div id="ref-belkin:laplacian" class="csl-entry" role="listitem">
Belkin, Mikhail, and Partha Niyogi. 2001. <span>“Laplacian Eigenmaps and Spectral Techniques for Embedding and Clustering.”</span> In <em>Proceedings of the 14th International Conference on Neural Information Processing Systems: Natural and Synthetic</em>, 585–91. Advances in Neural Information Processing Systems. Cambridge, MA, USA: MIT Press.
</div>
<div id="ref-bengio:learning" class="csl-entry" role="listitem">
Bengio, Yoshua. 2009. <em>Learning Deep Architectures for AI</em>. Now Publishers Inc.
</div>
<div id="ref-biggs:algebraic" class="csl-entry" role="listitem">
Biggs, Norman. 1993. <em>Algebraic Graph Theory</em>. 67. Cambridge university press.
</div>
<div id="ref-chernoff:use" class="csl-entry" role="listitem">
Chernoff, Herman. 1973. <span>“The Use of Faces to Represent Points in k-Dimensional Space Graphically.”</span> <em>Journal of the American Statistical Association</em> 68 (342): 361–68. <a href="http://www.jstor.org/stable/2284077">http://www.jstor.org/stable/2284077</a>.
</div>
<div id="ref-cook:visualizing" class="csl-entry" role="listitem">
Cook, James, Ilya Sutskever, Andriy Mnih, and Geoffrey Hinton. 2007. <span>“Visualizing Similarity Data with a Mixture of Maps.”</span> In <em>In Proceedings of the 11th International Conference on Artificial Intelligence and Statistics</em>, 2:67–74. PMLR.
</div>
<div id="ref-desilva:global" class="csl-entry" role="listitem">
De Silva, Vin, and Joshua B Tenenbaum. 2002. <span>“Global Versus Local Methods in Nonlinear Dimensionality Reduction.”</span> In <em>Advances in Neural Information Processing Systems</em>, 15:705–12.
</div>
<div id="ref-demartines:curvilinear" class="csl-entry" role="listitem">
Demartines, P., and J. Herault. 1997. <span>“Curvilinear Component Analysis: A Self-Organizing Neural Network for Nonlinear Mapping of Data Sets.”</span> <em>IEEE Transactions on Neural Networks</em> 8 (1): 148–54. <a href="https://doi.org/10.1109/72.554199">https://doi.org/10.1109/72.554199</a>.
</div>
<div id="ref-battista:algorithms" class="csl-entry" role="listitem">
Di Battista, Giuseppe, Peter Eades, Roberto Tamassia, and Ioannis G Tollisi. 1994. <span>“Algorithms for Drawing Graphs: An Annotated Bibliography.”</span> <em>Computational Geometry</em> 4 (5): 235–82. https://doi.org/<a href="https://doi.org/10.1016/0925-7721(94)00014-X">https://doi.org/10.1016/0925-7721(94)00014-X</a>.
</div>
<div id="ref-doyle:random" class="csl-entry" role="listitem">
Doyle, Peter G, and J Laurie Snell. 1984. <em>Random Walks and Electric Networks</em>. Vol. 22. American Mathematical Soc.
</div>
<div id="ref-ferreira:visual" class="csl-entry" role="listitem">
Ferreira de Oliveira, M. C., and H. Levkowitz. 2003. <span>“From Visual Data Exploration to Visual Data Mining: A Survey.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 9 (3): 378–94. <a href="https://doi.org/10.1109/TVCG.2003.1207445">https://doi.org/10.1109/TVCG.2003.1207445</a>.
</div>
<div id="ref-fokkema:jacobi" class="csl-entry" role="listitem">
Fokkema, Diederik R, Gerard LG Sleijpen, and Henk A Van der Vorst. 1998. <span>“Jacobi–Davidson Style QR and QZ Algorithms for the Reduction of Matrix Pencils.”</span> <em>SIAM Journal on Scientific Computing</em> 20 (1): 94–125.
</div>
<div id="ref-grady:random" class="csl-entry" role="listitem">
Grady, Leo. 2006. <span>“Random Walks for Image Segmentation.”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 28 (11): 1768–83.
</div>
<div id="ref-hinton:stochastic" class="csl-entry" role="listitem">
Hinton, Geoffrey E, and Sam Roweis. 2003. <span>“Stochastic Neighbor Embedding.”</span> In <em>Advances in Neural Information Processing Systems</em>, edited by S. Becker, S. Thrun, and K. Obermayer. Vol. 15. MIT Press. <a href="https://proceedings.neurips.cc/paper/2002/file/6150ccc6069bea6b5716254057a194ef-Paper.pdf">https://proceedings.neurips.cc/paper/2002/file/6150ccc6069bea6b5716254057a194ef-Paper.pdf</a>.
</div>
<div id="ref-hinton:reducing" class="csl-entry" role="listitem">
Hinton, Geoffrey E, and Ruslan R Salakhutdinov. 2006. <span>“Reducing the Dimensionality of Data with Neural Networks.”</span> <em>Science</em> 313 (5786): 504–7.
</div>
<div id="ref-hotelling:analysis" class="csl-entry" role="listitem">
Hotelling, H. 1933. <span>“Analysis of a Complex of Statistical Variables into Principal Components.”</span> <em>Journal of Educational Psychology</em> 24: 498–520.
</div>
<div id="ref-jacobs:rates" class="csl-entry" role="listitem">
Jacobs, Robert A. 1988. <span>“Increased Rates of Convergence Through Learning Rate Adaptation.”</span> <em>Neural Networks</em> 1 (4): 295–307.
</div>
<div id="ref-kakutani:dirichlet" class="csl-entry" role="listitem">
Kakutani, S. 1945. <span>“Markov Processes and the Dirichlet Problem.”</span> In <em>Proceedings of the Japan Academy</em>, 21:227–33.
</div>
<div id="ref-keim:designing" class="csl-entry" role="listitem">
Keim, Daniel A. 2000. <span>“Designing Pixel-Oriented Visualization Techniques: Theory and Applications.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 6 (1): 59–78. <a href="https://doi.org/10.1109/2945.841121">https://doi.org/10.1109/2945.841121</a>.
</div>
<div id="ref-lafon:diffusion" class="csl-entry" role="listitem">
Lafon, Stephane, and Ann B Lee. 2006. <span>“Diffusion Maps and Coarse-Graining: A Unified Framework for Dimensionality Reduction, Graph Partitioning, and Data Set Parameterization.”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 28 (9): 1393–403.
</div>
<div id="ref-lee:robust" class="csl-entry" role="listitem">
Lee, John Aldo, Amaury Lendasse, Nicolas Donckers, and Michel Verleysen. 2000. <span>“A Robust Nonlinear Projection Method.”</span> In <em>Proceedings of the 8th European Symposium on Artificial Neural Networks</em>, 13–20.
</div>
<div id="ref-lee:nonlinear2005" class="csl-entry" role="listitem">
Lee, John Aldo, and Michel Verleysen. 2005. <span>“Nonlinear Dimensionality Reduction of Data Manifolds with Essential Loops.”</span> <em>Neurocomputing</em> 67: 29–53.
</div>
<div id="ref-lee:nonlinear" class="csl-entry" role="listitem">
Lee, John A., and Michel Verleysen. 2007. <em>Nonlinear Dimensionality Reduction</em>. 1st ed. Springer Publishing Company, Incorporated.
</div>
<div id="ref-mardia:multivariate" class="csl-entry" role="listitem">
Mardia, Kent, KV, and J Bibby. 1979. <em>Multivariate Analysis</em>. Academic Press Amsterdam.
</div>
<div id="ref-meytlis:face" class="csl-entry" role="listitem">
Meytlis, Marsha, and Lawrence Sirovich. 2007. <span>“On the Dimensionality of Face Space.”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 29 (7): 1262–67.
</div>
<div id="ref-nadler:diffusion" class="csl-entry" role="listitem">
Nadler, B, S Lafon, RR Coifman, and IG Kevrekidis. 2006. <span>“Diffusion Maps, Spectral Clustering, and the Reaction Coordinates of Dynamical Systems.”</span> <em>Applied and Computational Harmonic Analysis: Special Issue on Diffusion Maps and Wavelets</em> 21: 113–27.
</div>
<div id="ref-nene:coil20" class="csl-entry" role="listitem">
Nene, Sameer A, Shree K Nayar, and Hiroshi Murase. 1996. <span>“Columbia Object Image Library (COIL-20).”</span> CUCS-005-96. Columbia University.
</div>
<div id="ref-roweis:nonlinear" class="csl-entry" role="listitem">
Roweis, Sam T., and Lawrence K. Saul. 2000. <span>“<span class="nocase">Nonlinear Dimensionality Reduction by Locally Linear Embedding</span>.”</span> <em>Science</em> 290 (5500): 2323–26. <a href="https://doi.org/10.1126/science.290.5500.2323">https://doi.org/10.1126/science.290.5500.2323</a>.
</div>
<div id="ref-sammon:nonlinear" class="csl-entry" role="listitem">
Sammon, J. W. 1969. <span>“A Nonlinear Mapping for Data Structure Analysis.”</span> <em>IEEE Transactions on Computers</em> C-18 (5): 401–9. <a href="https://doi.org/10.1109/T-C.1969.222678">https://doi.org/10.1109/T-C.1969.222678</a>.
</div>
<div id="ref-song:colored" class="csl-entry" role="listitem">
Song, Le, Alexander J Smola, Karsten M Borgwardt, and Arthur Gretton. 2008. <span>“Colored Maximum Variance Unfolding.”</span> In <em>Advances in Neural Information Processing Systems</em>, edited by J. Platt, D. Koller, Y. Singer, and S. Roweis. Vol. 20. Curran Associates, Inc. <a href="https://proceedings.neurips.cc/paper/2007/file/55a7cf9c71f1c9c495413f934dd1a158-Paper.pdf">https://proceedings.neurips.cc/paper/2007/file/55a7cf9c71f1c9c495413f934dd1a158-Paper.pdf</a>.
</div>
<div id="ref-street:nuclear" class="csl-entry" role="listitem">
Street, W. Nick, W. H. Wolberg, and O. L. Mangasarian. 1993. <span>“<span class="nocase">Nuclear feature extraction for breast tumor diagnosis</span>.”</span> In <em>Biomedical Image Processing and Biomedical Visualization</em>, edited by Raj S. Acharya and Dmitry B. Goldgof, 1905:861–70. International Society for Optics; Photonics; SPIE. <a href="https://doi.org/10.1117/12.148698">https://doi.org/10.1117/12.148698</a>.
</div>
<div id="ref-jaakola:partially" class="csl-entry" role="listitem">
Szummer, Martin, and Tommi Jaakkola. 2002. <span>“Partially Labeled Classification with Markov Random Walks.”</span> <em>Advances in Neural Information Processing Systems</em> 14: 945–52.
</div>
<div id="ref-tenenbaum:global" class="csl-entry" role="listitem">
Tenenbaum, Joshua B., Vin de Silva, and John C. Langford. 2000. <span>“A Global Geometric Framework for Nonlinear Dimensionality Reduction.”</span> <em>Science</em> 290 (5500): 2319.
</div>
<div id="ref-torgerson:multidimensional" class="csl-entry" role="listitem">
Torgerson, W. S. 1952. <span>“Multidimensional Scaling: I. Theory and Method.”</span> <em>Psychometrika</em> 17: 401–19.
</div>
<div id="ref-vandermaaten:comparison" class="csl-entry" role="listitem">
Van Der Maaten, Laurens, Eric Postma, Jaap Van den Herik, et al. 2009. <span>“Dimensionality Reduction: A Comparative.”</span> <em>J Mach Learn Res</em> 10 (66-71): 13.
</div>
<div id="ref-weinberger:learning" class="csl-entry" role="listitem">
Weinberger, Kilian Q., Fei Sha, and Lawrence K. Saul. 2004. <span>“Learning a Kernel Matrix for Nonlinear Dimensionality Reduction.”</span> In <em>Proceedings of the Twenty-First International Conference on Machine Learning</em>, 106. ICML ’04. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/1015330.1015345">https://doi.org/10.1145/1015330.1015345</a>.
</div>
<div id="ref-weinberger:graph" class="csl-entry" role="listitem">
Weinberger, Kilian Q, Fei Sha, Qihui Zhu, and Lawrence K Saul. 2007. <span>“Graph Laplacian Regularization for Large-Scale Semidefinite Programming.”</span> In <em>Advances in Neural Information Processing Systems</em>, 1489–96.
</div>
<div id="ref-williams:connection" class="csl-entry" role="listitem">
Williams, Christopher KI. 2002. <span>“On a Connection Between Kernel PCA and Metric Multidimensional Scaling.”</span> <em>Machine Learning</em> 46 (1): 11–19.
</div>
<div id="ref-zhu:semi" class="csl-entry" role="listitem">
Zhu, Xiaojin, Zoubin Ghahramani, and John D Lafferty. 2003. <span>“Semi-Supervised Learning Using Gaussian Fields and Harmonic Functions.”</span> In <em>Proceedings of the 20th International Conference on Machine Learning (ICML-03)</em>, 912–19.
</div>
</div>
</section>




<div id="quarto-appendix" class="default"><section id="appendix-a-derivation-of-the-t-sne-gradient" class="level1 appendix unnumbered"><h2 class="anchored quarto-appendix-heading">Appendix A: Derivation of the t-SNE gradient</h2><div class="quarto-appendix-contents">

<p>t-SNE minimizes the Kullback-Leibler divergence between the joint probabilities <span class="math inline">p_{ij}</span> in the highdimensional space and the joint probabilities <span class="math inline">q_{ij}</span> in the low-dimensional space. The values of <span class="math inline">p_{ij}</span> are defined to be the symmetrized conditional probabilities, whereas the values of <span class="math inline">q_{ij}</span> are obtained by means of a Student-t distribution with one degree of freedom</p>
<p><span class="math display">
\begin{aligned}
p_{ij} &amp; = \frac{p_{j|i} + p_{i|j}}{2 n} \\
q_{ij} &amp; = \frac{\left(1 + \|y_i - y_j \|^2\right)^{-1}}{\sum_{k\neq \ell} \left(1 + \|y_k - y_\ell \|^2\right)^{-1}}
\end{aligned}
</span></p>
<p>where <span class="math inline">p_{j|i}</span> and <span class="math inline">p_{i|j}</span> are either obtained from Equation 1 or from the random walk procedure described in <a href="#sec-large-data" class="quarto-xref">Section&nbsp;5</a>. The values of <span class="math inline">p_{ii}</span> and <span class="math inline">q_{ii}</span> are set to zero. The Kullback-Leibler divergence between the two joint probability distributions <span class="math inline">P</span> and <span class="math inline">Q</span> is given by</p>
<p><span id="eq-appendixa1"><span class="math display">
C = KL(P \| Q) = \sum_i \sum_j p_{ij} \log \frac{p_{ij}}{q_{ij}}  = \sum_i \sum_j p_{ij} \log p_{ij} - p_{ij} \log q_{ij}.
\tag{6}</span></span></p>
<p>In order to make the derivation less cluttered, we define two auxiliary variables <span class="math inline">d_{ij}</span> and <span class="math inline">Z</span> as follows</p>
<p><span class="math display">
\begin{aligned}
d_{ij} &amp; = \|y_i - y_j\|, \\
Z &amp; = \sum_{k\neq \ell} \left(1 + d_{k\ell}^2 \right)^{-1}.
\end{aligned}
</span></p>
<p>Note that if <span class="math inline">y_i</span> changes, the only pairwise distances that change are <span class="math inline">d_{ij}</span> and <span class="math inline">d_{ji}</span> for all <span class="math inline">j</span>. Hence, the gradient of the cost function <span class="math inline">C</span> with respect to <span class="math inline">y_i</span> is given by</p>
<p><span id="eq-appendixa2"><span class="math display">
\frac{\partial C}{\partial y_i} = \sum_j \left(\frac{\partial C}{\partial d_{ij}} + \frac{\partial C}{\partial d_{ji}}\right) (y_i - y_j) = 2 \sum_j \frac{\partial C}{\partial d_{ij}} (y_i - y_j)
\tag{7}</span></span></p>
<p>The gradient <span class="math inline">\frac{\partial C}{\partial d_{ji}}</span> is computed from the definition of the Kullback-Leibler divergence in <a href="#eq-appendixa1" class="quarto-xref">Equation&nbsp;6</a> (note that he first part of this equation is a constant).</p>
<p><span class="math display">
\begin{aligned}
\frac{\partial C}{\partial d_{ij}}
&amp; = - \sum_{k\neq\ell} p_{k\ell} \frac{\partial \log q_{k\ell}}{\partial d_{ij}} \\
&amp; = - \sum_{k\neq\ell} p_{k\ell} \frac{\partial \log q_{k\ell}Q - \log Z}{\partial d_{ij}} \\
&amp; = - \sum_{k\neq\ell} p_{k\ell} \left(\frac{1}{q_{k\ell}Z} \frac{\partial ((1 - d_{k\ell}^2)^{-1})}{\partial d_{ij}} - \frac{1}{Z}\frac{\partial Z}{\partial d_{ij}} \right) )
\end{aligned}
</span></p>
<p>The gradient <span class="math inline">\frac{\partial ((1 - d_{k\ell}^2)^{-1})}{\partial d_{ij}}</span> is only onzero when <span class="math inline">k=i</span> and <span class="math inline">\ell = j</span>. Hence, the gradient <span class="math inline">\frac{\partial C}{\partial d_{ij}}</span> is given by</p>
<p><span class="math display">
\frac{\partial C}{\partial d_{ij}} + 2 \frac{p{ij}}{q_{ij}Z} (1 = d_{ij}^2)^{-2} - 2 \sum_{k\neq \ell} p_{k\ell} \frac{(1+d_{ij}^2)^{-2}}{Z}.
</span></p>
<p>Noting that <span class="math inline">\sum_{k\neq \ell} p_{k\ell} = 1</span>, we see that the gradients simplifies to</p>
<p><span class="math display">
\begin{aligned}
\frac{\partial C}{\partial d_{ij}} &amp; = 2 p{ij} (1 + d_{ij}^2)^{-1} - 2 q_{ij}(1 + d_{ij}^2)^{-1} \\
&amp; = 2 (p{ij} - q_{ij}) (1 + d_{ij}^2)^{-1}.
\end{aligned}
</span></p>
<p>Substituting this term into <a href="#eq-appendixa2" class="quarto-xref">Equation&nbsp;7</a>, we obtain the gradient</p>
<p><span class="math display">
\frac{\partial C}{\partial y_i} = 4 \sum_j (p{ij} - q_{ij}) (1 + \|y_i - y_j\|^2)^{-1} (y_i - y_j).
</span></p>
</div></section><section id="appendix-b-analytical-solution-to-random-walk-probabilities" class="level1 appendix unnumbered"><h2 class="anchored quarto-appendix-heading">Appendix B: Analytical Solution to Random Walk Probabilities</h2><div class="quarto-appendix-contents">

<p>Below, we describe the analytical solution to the random walk probabilities that are employed in the random walk version of t-SNE (<a href="#sec-large-data" class="quarto-xref">Section&nbsp;5</a>). The solution is described in more detail <span class="citation" data-cites="grady:random">Grady (<a href="#ref-grady:random" role="doc-biblioref">2006</a>)</span>.</p>
<p>It can be shown that computing the probability that a random walk initiated from a non-landmark point (on a graph that is specified by adjacency matrix W) first reaches a specific landmark point is equal to computing the solution to the combinatorial Dirichlet problem in which the boundary conditions are at the locations of the landmark points, the considered landmark point is fixed to unity, and the other landmarks points are set to zero <span class="citation" data-cites="kakutani:dirichlet">Kakutani (<a href="#ref-kakutani:dirichlet" role="doc-biblioref">1945</a>)</span> ; <span class="citation" data-cites="doyle:random">Doyle and Snell (<a href="#ref-doyle:random" role="doc-biblioref">1984</a>)</span>. In practice, the solution can thus be obtained by minimizing the combinatorial formulation of the Dirichlet integral</p>
<p><span class="math display">
D[x] = \frac12 x^\top L x,
</span></p>
<p>where <span class="math inline">L</span> represents the graph Laplacian. Mathematically, the graph Laplacian is given by <span class="math inline">L = D−W</span>, where <span class="math inline">D = \mathrm{diag} (\sum_j
w_{1j}, \sum_j w_{2j}, \dots, \sum_j w_{nj} )</span>. Without loss of generality, we may reorder the landmark points such that the landmark points come first. As a result, the combinatorial Dirichlet integral decomposes into</p>
<p><span class="math display">
\begin{aligned}
D_{x_N} &amp; = \frac12
\left[\begin{array}{cc}
x_L^\top &amp; x_N^\top \end{array}\right] \,
\left[\begin{array}{cc}  L_L &amp; B \\ B^\top &amp; L_N \end{array}\right] \,
\left[\begin{array}{c}
x_L \\ x_N \end{array}\right] \\
&amp; = \frac12 (x_L^\top L_L x_L + 2 x_N^\top B^\top x_L + x_N^\top L_N x_N),
\end{aligned}
</span></p>
<p>where we use the subscript <span class="math inline">{\cdot}_L</span> to indicate the landmark points, and the subscript <span class="math inline">{\cdot}_N</span> to indicate the non-landmark points. Differentiating <span class="math inline">D[x_N]</span> with respect to <span class="math inline">x_N</span> and finding its critical points amounts to solving the linear systems</p>
<p><span id="eq-appendixb1"><span class="math display">
L_N x_N = −B^\top.
\tag{8}</span></span></p>
<p>Please note that in this linear system, <span class="math inline">B^\top</span> is a matrix containing the columns from the graph Laplacian <span class="math inline">L</span> that correspond to the landmark points (excluding the rows that correspond to landmark points). After normalization of the solutions to the systems <span class="math inline">X_N</span>, the column vectors of <span class="math inline">X_N</span> contain the probability that a random walk initiated from a non-landmark point terminates in a landmark point. One should note that the linear system in <a href="#eq-appendixb1" class="quarto-xref">Equation&nbsp;8</a> is only nonsingular if the graph is completely connected, or if each connected component in the graph contains at least one landmark point <span class="citation" data-cites="biggs:algebraic">Biggs (<a href="#ref-biggs:algebraic" role="doc-biblioref">1993</a>)</span>.</p>
<p>Because we are interested in the probability of a random walk initiated from a landmark point terminating at another landmark point, we duplicate all landmark points in the neighborhood graph, and initiate the random walks from the duplicate landmarks. Because of memory constraints, it is not possible to store the entire matrix <span class="math inline">X_N</span> into memory (note that we are only interested in a small number of rows from this matrix, viz., in the rows corresponding to the duplicate landmark points). Hence, we solve the linear systems defined by the columns of <span class="math inline">−B^\top</span> one-by-one, and store only the parts of the solutions that correspond to the duplicate landmark points. For computational reasons, we first perform a Cholesky factorization of <span class="math inline">L_N</span>, such that <span class="math inline">L_N = C C^\top</span>, where <span class="math inline">C</span> is an upper-triangular matrix. Subsequently, the solution to the linear system in Equation <a href="#eq-appendixb1" class="quarto-xref">Equation&nbsp;8</a> is obtained by solving the linear systems <span class="math inline">Cy = −B^\top</span> and <span class="math inline">C x_N = y</span> using a fast backsubstitution method.</p>
<!-- -->

</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>SNE can also be applied to data sets that consist of pairwise similarities between objects rather than high-dimensional vector representations of each object, provided these similarities can be interpreted as conditional probabilities. For example, human word associations data consists of the probability of producing each possible word in response to a given word, as a result of which it is already in the form required by SNE.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Setting the variance in the low-dimensional Gaussians to another value only results in a rescaled version of the final map. Note that by using the same variance for every datapoint in the low-dimensional map, we lose the property that the data is a perfect model of itself if we embed it in a space of the same dimensionality, because in the high-dimensional space, we used a different variance <span class="math inline">\sigma_i</span> in each Gaussian.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Note that the perplexity increases monotonically with the variance <span class="math inline">\sigma_i</span>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Picking the best map after several runs as visualization of the data is not nearly as problematic as picking the model that does best on a test set during supervised learning. In visualization, the aim is to see the structure in the training data, not to generalize to held out test data.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>The MNIST data set is publicly available from <a href="http://yann.lecun.com/exdb/mnist/index.html" class="uri">http://yann.lecun.com/exdb/mnist/index.html</a>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>The Olivetti data set is publicly available from <a href="http://mambo.ucsc.edu/psl/olivetti.html" class="uri">http://mambo.ucsc.edu/psl/olivetti.html</a>.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>Isomap and LLE require data that gives rise to a neighborhood graph that is connected.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>In preliminary experiments, we found the performance of random walk t-SNE to be very robust under changes of <span class="math inline">k</span>.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{van der maaten2008,
  author = {van der Maaten, Laurens and Hinton, Geoffrey},
  publisher = {Société Française de Statistique},
  title = {Visualizing {Data} Using {t-SNE:} A Practical Computo Example
    (Mock)},
  journal = {Computo},
  date = {2008-08-11},
  url = {https://computo.sfds.asso.fr/published-paper-tsne},
  issn = {2824-7795},
  langid = {en},
  abstract = {We present a new technique called “t-SNE” that visualizes
    high-dimensional data by giving each datapoint a location in a two
    or three-dimensional map. The technique is a variation of Stochastic
    Neighbor Embedding hinton:stochastic that is much easier to
    optimize, and produces significantly better visualizations by
    reducing the tendency to crowd points together in the center of the
    map. t-SNE is better than existing techniques at creating a single
    map that reveals structure at many different scales. This is
    particularly important for high-dimensional data that lie on several
    different, but related, low-dimensional manifolds, such as images of
    objects from multiple classes seen from multiple viewpoints. For
    visualizing the structure of very large data sets, we show how t-SNE
    can use random walks on neighborhood graphs to allow the implicit
    structure of all the data to influence the way in which a subset of
    the data is displayed. We illustrate the performance of t-SNE on a
    wide variety of data sets and compare it with many other
    non-parametric visualization techniques, including Sammon mapping,
    Isomap, and Locally Linear Embedding. The visualization produced by
    t-SNE are significantly better than those produced by other
    techniques on almost all of the data sets. \textless
    br/\textgreater{}}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-van der maaten2008" class="csl-entry quarto-appendix-citeas" role="listitem">
Maaten, Laurens van der, and Geoffrey Hinton. 2008. <span>“Visualizing
Data Using t-SNE: A Practical Computo Example (Mock).”</span>
<em>Computo</em>, August. <a href="https://computo.sfds.asso.fr/published-paper-tsne">https://computo.sfds.asso.fr/published-paper-tsne</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb5" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Visualizing Data using t-SNE"</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "A practical computo example"</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> 2008-08-11</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> |</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">  This page is a reworking of the original t-SNE article using the Computo template. It aims to help authors submitting to the journal by using some advanced formatting features. We warmly thank the authors of t-SNE and the editor of JMLR for allowing us to use their work to illustrate the Computo spirit.</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> </span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Laurens van der Maaten</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://lvdmaaten.github.io/</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliation: TiCC, Tilburg University</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliation-url: https://www.tilburguniversity.edu/</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-1931-6828</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co">      </span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Geoffrey Hinton</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://www.cs.toronto.edu/~hinton/</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliation: Department of Computer Science, University of Toronto</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliation-url: https://web.cs.toronto.edu/</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-8063-7209</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> |</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="co">  We present a new technique called "t-SNE" that visualizes high-dimensional data by giving each datapoint a location in a two or three-dimensional map.  The technique is a variation of Stochastic Neighbor Embedding hinton:stochastic that is much easier to optimize, and produces significantly better visualizations by reducing the tendency to crowd points together in the center of the map. t-SNE is better than existing techniques at creating a single map that reveals structure at many different scales. This is particularly important for high-dimensional data that lie on several different, but related, low-dimensional manifolds, such as images of objects from multiple classes seen from multiple viewpoints. For visualizing the structure of very large data sets, we show how t-SNE can use random walks on neighborhood graphs to allow the implicit structure of all the data to influence the way in which a subset of the data is displayed. We illustrate the performance of t-SNE on a wide variety of data sets and compare it with many other non-parametric visualization techniques, including Sammon mapping, Isomap, and Locally Linear Embedding. The visualization produced by t-SNE are significantly better than those produced by other techniques on almost all of the data sets. &lt;br/&gt;</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [visualization, dimensionality reduction, manifold learning, embedding algorithms, multidimensional scaling]</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> computorg</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "published-paper-tsne"</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> false</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> true</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span class="co">  title: "Visualizing Data using t-SNE: a practical computo example (mock)"</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "Société Française de Statistique"</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a><span class="co">  url: https://computo.sfds.asso.fr/published-paper-tsne</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span><span class="co"> </span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: default</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-pdf: default</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a><span class="co">  keep-ipynb: true</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a><span class="co">  warning: false  </span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> python3</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>Visualization of high-dimensional data is an important problem in many</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>different domains, and deals with data of widely varying dimensionality. Cell</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>nuclei that are relevant to breast cancer, for example, are described by</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>approximately 30 variables @street:nuclear, whereas the pixel</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>intensity vectors used to represent images or the word-count vectors used to</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>represent documents typically have thousands of dimensions. Over the last few</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>decades, a variety of techniques for the visualization of such high-dimensional</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>data have been proposed, many of which are reviewed by @ferreira:visual.</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>Important techniques include iconographic displays such as Chernoff faces @chernoff:use, </span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>pixel-based techniques @keim:designing, and techniques that represent the dimensions in the </span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>data as vertices in a graph @battista:algorithms. Most of these techniques simply</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>provide tools to display more than two data dimensions, and leave the</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>interpretation of the data to the human observer. This severely limits the</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>applicability of these techniques to real-world data sets that contain</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>thousands of high-dimensional datapoints.</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>In contrast to the visualization techniques discussed above, dimensionality</span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>reduction methods convert the high-dimensional data set $\mathcal{X} = {x_1,</span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>x_2, \dots, x_n}$ into two or three-dimensional data $\mathcal{Y} = {y_1, y_2,</span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>\dots, y_n}$ that can be displayed in a scatterplot. In the paper, we refer to</span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>the low-dimensional data representation $\mathcal{Y}$ as a map, and to the</span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>low-dimensional representations $y_i$ of individual datapoints as map</span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>points. The aim of dimensionality reduction is to preserve as much of the</span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>significant structure of the high-dimensional data as possible in the</span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>low-dimensional map. Various techniques for this problem have been proposed</span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>that differ in the type of structure they preserve. Traditional dimensionality</span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>reduction techniques such as Principal Components Analysis</span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>@hotelling:analysis  and classical multidimensional scaling</span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>@torgerson:multidimensional are linear techniques that focus on keeping</span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>the low-dimensional representations of dissimilar datapoints far apart. For</span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a>high-dimensional data that lies on or near a low-dimensional, non-linear</span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a>manifold it is usually more important to keep the low-dimensional</span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a>representations of very similar datapoints close together, which is typically</span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a>not possible with a linear mapping.</span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a>A large number of nonlinear dimensionality reduction techniques that aim to</span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a>preserve the local structure of data have been proposed, many of which are</span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a>reviewed by @lee:nonlinear. In particular, we mention the following</span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a>seven techniques: (1) Sammon mapping @sammon:nonlinear, (2) curvilinear</span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a>components analysis @demartines:curvilinear, (3) Stochastic Neighbor</span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a>Embedding @hinton:stochastic; (4) Isomap @tenenbaum:global, (5)</span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a>Maximum Variance Unfolding @weinberger:learning; (6) Locally Linear</span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a>Embedding @roweis:nonlinear, and (7) Laplacian Eigenmaps</span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a>@belkin:laplacian. Despite the strong performance of these techniques</span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a>on artificial data sets, they are often not very successful at visualizing</span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a>real, high-dimensional data. In particular, most of the techniques are not</span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a>capable of retaining both the local and the global structure of the data in a</span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a>single map. For instance, a recent study reveals that even a semi-supervised</span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a>variant of MVU is not capable of separating handwritten digits into their</span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a>natural clusters @song:colored.</span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a>In this paper, we describe a way of converting a high-dimensional data</span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a>set into a matrix of pairwise similarities and we introduce a new</span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a>technique, called "t-SNE", for visualizing the resulting similarity</span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a>data. t-SNE is capable of capturing much of the local structure of the</span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a>high-dimensional data very well, while also revealing global structure</span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a>such as the presence of clusters at several scales. We illustrate the</span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true" tabindex="-1"></a>performance of t-SNE by comparing it to the seven dimensionality</span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true" tabindex="-1"></a>reduction techniques mentioned above on five data sets from a variety</span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a>of domains. Because of space limitations, most of the</span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a>$(7+1)\times5=40$ maps are presented in the supplemental material, but</span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a>the maps that we present in the paper are sufficient to demonstrate</span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a>the superiority of t-SNE.</span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a>The outline of the paper is as follows. In  @sec-sne, we</span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a>outline SNE as presented by @hinton:stochastic, which forms</span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a>the basis for t-SNE. In  @sec-tsne, we present t-SNE, which</span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a>has two important differences from SNE. In Section</span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a>@sec-experiments, we describe the experimental setup and the</span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a>results of our experiments.  Subsequently, @sec-large-data shows how t-SNE can be modified to visualize</span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true" tabindex="-1"></a>real-world data sets that contain many more than 10,000</span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true" tabindex="-1"></a>datapoints. The results of our experiments are discussed in more</span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true" tabindex="-1"></a>detail in  @sec-discussion. Our conclusions and suggestions</span>
<span id="cb5-119"><a href="#cb5-119" aria-hidden="true" tabindex="-1"></a>for future work are presented in  @sec-conclusion.</span>
<span id="cb5-120"><a href="#cb5-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-121"><a href="#cb5-121" aria-hidden="true" tabindex="-1"></a><span class="fu"># Stochastic Neighbor Embedding {#sec-sne}</span></span>
<span id="cb5-122"><a href="#cb5-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-123"><a href="#cb5-123" aria-hidden="true" tabindex="-1"></a>Stochastic Neighbor Embedding (SNE) starts by converting the</span>
<span id="cb5-124"><a href="#cb5-124" aria-hidden="true" tabindex="-1"></a>high-dimensional Euclidean distances between datapoints into</span>
<span id="cb5-125"><a href="#cb5-125" aria-hidden="true" tabindex="-1"></a>conditional probabilities that represent similarities.<span class="ot">[^SNE]</span> The</span>
<span id="cb5-126"><a href="#cb5-126" aria-hidden="true" tabindex="-1"></a>similarity of datapoint $x_j$ to datapoint $x_i$ is the conditional</span>
<span id="cb5-127"><a href="#cb5-127" aria-hidden="true" tabindex="-1"></a>probabilities, $p_{j|i}$, that $x_i$ would pick $x_j$ as its neighbor</span>
<span id="cb5-128"><a href="#cb5-128" aria-hidden="true" tabindex="-1"></a>if neighbors were picked in proportion to their probability density</span>
<span id="cb5-129"><a href="#cb5-129" aria-hidden="true" tabindex="-1"></a>under a Gaussian centered at $x_i$. For nearby datapoints, $p_{j|i}$</span>
<span id="cb5-130"><a href="#cb5-130" aria-hidden="true" tabindex="-1"></a>is relatively high, whereas for widely separated datapoints, $p_{j|i}$</span>
<span id="cb5-131"><a href="#cb5-131" aria-hidden="true" tabindex="-1"></a>will be almost infinitesimal (for reasonable values of the variance of</span>
<span id="cb5-132"><a href="#cb5-132" aria-hidden="true" tabindex="-1"></a>the Gaussian, $\sigma_i$). Mathematically, the conditional probability</span>
<span id="cb5-133"><a href="#cb5-133" aria-hidden="true" tabindex="-1"></a>$p_{j|i}$ is given by</span>
<span id="cb5-134"><a href="#cb5-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-135"><a href="#cb5-135" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-136"><a href="#cb5-136" aria-hidden="true" tabindex="-1"></a>p_{j|i} = \frac{\exp(-\|x_i - x_j\|^2/(2\sigma_i^2))}{\sum_{k\neq i} \exp(-\|x_i</span>
<span id="cb5-137"><a href="#cb5-137" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>x_k\|^2 / 2 \sigma_i^2)}\,.</span>
<span id="cb5-138"><a href="#cb5-138" aria-hidden="true" tabindex="-1"></a>$$ {#eq-sne_large_space}</span>
<span id="cb5-139"><a href="#cb5-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-140"><a href="#cb5-140" aria-hidden="true" tabindex="-1"></a>where $\sigma_i$ is the variance of the Gaussian that is centered on datapoint</span>
<span id="cb5-141"><a href="#cb5-141" aria-hidden="true" tabindex="-1"></a>$x_i$. The method for determining the value of $\sigma_i$ is presented later</span>
<span id="cb5-142"><a href="#cb5-142" aria-hidden="true" tabindex="-1"></a>in this section. Because we are only interested in modeling pairwise</span>
<span id="cb5-143"><a href="#cb5-143" aria-hidden="true" tabindex="-1"></a>similarities, we set the value of $p_{i|i}$ to zero. For the low-dimensional</span>
<span id="cb5-144"><a href="#cb5-144" aria-hidden="true" tabindex="-1"></a>counterparts $y_i$ and $y_j$ of the high-dimensional datapoints $x_i$ and $x_j$,</span>
<span id="cb5-145"><a href="#cb5-145" aria-hidden="true" tabindex="-1"></a>it is possible to compute a similar conditional probability, which we denote</span>
<span id="cb5-146"><a href="#cb5-146" aria-hidden="true" tabindex="-1"></a>by $q_{j|i}$. We set <span class="ot">[^variance]</span> the variance of the Gaussian that is employed</span>
<span id="cb5-147"><a href="#cb5-147" aria-hidden="true" tabindex="-1"></a>in the computation of the conditional probabilities $q_{j|i}$ to</span>
<span id="cb5-148"><a href="#cb5-148" aria-hidden="true" tabindex="-1"></a>$\frac{1}{\sqrt{2}}$. Hence, we model the similarity of a map point $y_j$ to</span>
<span id="cb5-149"><a href="#cb5-149" aria-hidden="true" tabindex="-1"></a>map point $y_i$ by</span>
<span id="cb5-150"><a href="#cb5-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-151"><a href="#cb5-151" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-152"><a href="#cb5-152" aria-hidden="true" tabindex="-1"></a>q_{j|i} = \frac{\exp(-\|y_i - y_j\|^2)}{\sum_{k \neq i} \exp(-\|y_i</span>
<span id="cb5-153"><a href="#cb5-153" aria-hidden="true" tabindex="-1"></a>-y_k\|^2)}\,.</span>
<span id="cb5-154"><a href="#cb5-154" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-155"><a href="#cb5-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-156"><a href="#cb5-156" aria-hidden="true" tabindex="-1"></a><span class="ot">[^SNE]: </span>SNE can also be applied to data sets that consist of pairwise</span>
<span id="cb5-157"><a href="#cb5-157" aria-hidden="true" tabindex="-1"></a>  similarities between objects rather than high-dimensional vector</span>
<span id="cb5-158"><a href="#cb5-158" aria-hidden="true" tabindex="-1"></a>  representations of each object, provided these similarities can be</span>
<span id="cb5-159"><a href="#cb5-159" aria-hidden="true" tabindex="-1"></a>  interpreted as conditional probabilities. For example, human word</span>
<span id="cb5-160"><a href="#cb5-160" aria-hidden="true" tabindex="-1"></a>  associations data consists of the probability of producing each possible</span>
<span id="cb5-161"><a href="#cb5-161" aria-hidden="true" tabindex="-1"></a>  word in response to a given word, as a result of which it is already in the</span>
<span id="cb5-162"><a href="#cb5-162" aria-hidden="true" tabindex="-1"></a>  form required by SNE.</span>
<span id="cb5-163"><a href="#cb5-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-164"><a href="#cb5-164" aria-hidden="true" tabindex="-1"></a><span class="ot">[^variance]: </span>Setting the variance in the low-dimensional Gaussians to another</span>
<span id="cb5-165"><a href="#cb5-165" aria-hidden="true" tabindex="-1"></a>  value only results in a rescaled version of the final map. Note that by</span>
<span id="cb5-166"><a href="#cb5-166" aria-hidden="true" tabindex="-1"></a>  using the same variance for every datapoint in the low-dimensional map, we</span>
<span id="cb5-167"><a href="#cb5-167" aria-hidden="true" tabindex="-1"></a>  lose the property that the data is a perfect model of itself if we embed it</span>
<span id="cb5-168"><a href="#cb5-168" aria-hidden="true" tabindex="-1"></a>  in a space of the same dimensionality, because in the high-dimensional</span>
<span id="cb5-169"><a href="#cb5-169" aria-hidden="true" tabindex="-1"></a>  space, we used a different variance $\sigma_i$ in each Gaussian.</span>
<span id="cb5-170"><a href="#cb5-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-171"><a href="#cb5-171" aria-hidden="true" tabindex="-1"></a>Again, since we are only interested in modeling pairwise similarities, we set</span>
<span id="cb5-172"><a href="#cb5-172" aria-hidden="true" tabindex="-1"></a>$q_{i|i}=0$.</span>
<span id="cb5-173"><a href="#cb5-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-174"><a href="#cb5-174" aria-hidden="true" tabindex="-1"></a>If the map points $y_i$ and $y_j$ correctly model the similarity between the</span>
<span id="cb5-175"><a href="#cb5-175" aria-hidden="true" tabindex="-1"></a>high-dimensional data-points $x_i$ and $x_j$, the conditional probabilities</span>
<span id="cb5-176"><a href="#cb5-176" aria-hidden="true" tabindex="-1"></a>$p_{j|i}$ and $q_{j|i}$ will be equal. Motivated by this observation, SNE aims</span>
<span id="cb5-177"><a href="#cb5-177" aria-hidden="true" tabindex="-1"></a>to find a low-dimensional data representation that minimizes the mismatch</span>
<span id="cb5-178"><a href="#cb5-178" aria-hidden="true" tabindex="-1"></a>between $p_{j|i}$ and $q_{j|i}$. A natural measure of the faithfulness with</span>
<span id="cb5-179"><a href="#cb5-179" aria-hidden="true" tabindex="-1"></a>which $q_{j|i}$ models $p_{j|i}$ is the Kullback-Leibler divergence (which is</span>
<span id="cb5-180"><a href="#cb5-180" aria-hidden="true" tabindex="-1"></a>in the case equal to the cross-entropy up to an additive constant). SNE</span>
<span id="cb5-181"><a href="#cb5-181" aria-hidden="true" tabindex="-1"></a>minimizes the sum of Kullback-Leibler divergences over all datapoints using a</span>
<span id="cb5-182"><a href="#cb5-182" aria-hidden="true" tabindex="-1"></a>gradient descent method. The cost function $C$ is given by</span>
<span id="cb5-183"><a href="#cb5-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-184"><a href="#cb5-184" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-185"><a href="#cb5-185" aria-hidden="true" tabindex="-1"></a>C = \sum_i KL(P_i\|Q_i) = \sum_i \sum_j p_{j|i} \log</span>
<span id="cb5-186"><a href="#cb5-186" aria-hidden="true" tabindex="-1"></a>\frac{p_{j|i}}{q_{j|i}}\,,</span>
<span id="cb5-187"><a href="#cb5-187" aria-hidden="true" tabindex="-1"></a>$$ {#eq-sne_cost_function}</span>
<span id="cb5-188"><a href="#cb5-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-189"><a href="#cb5-189" aria-hidden="true" tabindex="-1"></a>in which $P_i$ represents the conditional probability distribution</span>
<span id="cb5-190"><a href="#cb5-190" aria-hidden="true" tabindex="-1"></a>over all other datapoints given datapoint $x_i$, and $Q_i$ represents</span>
<span id="cb5-191"><a href="#cb5-191" aria-hidden="true" tabindex="-1"></a>the conditional probability distribution over all other map points</span>
<span id="cb5-192"><a href="#cb5-192" aria-hidden="true" tabindex="-1"></a>given map point $y_i$.  Because the Kullback-Liebler divergence is not</span>
<span id="cb5-193"><a href="#cb5-193" aria-hidden="true" tabindex="-1"></a>symmetric, different types of error in the pairwise distances in the</span>
<span id="cb5-194"><a href="#cb5-194" aria-hidden="true" tabindex="-1"></a>low-dimensional map are not weighted equally. In particular, there is</span>
<span id="cb5-195"><a href="#cb5-195" aria-hidden="true" tabindex="-1"></a>a large cost for using widely separated map points to represent nearby</span>
<span id="cb5-196"><a href="#cb5-196" aria-hidden="true" tabindex="-1"></a>datapoints (i.e, for using a small $q_{j|i}$ to model a large</span>
<span id="cb5-197"><a href="#cb5-197" aria-hidden="true" tabindex="-1"></a>$p_{j|i}$), but there is only a small cost for using nearby map points</span>
<span id="cb5-198"><a href="#cb5-198" aria-hidden="true" tabindex="-1"></a>to represent widely separated datapoints. This small cost comes from</span>
<span id="cb5-199"><a href="#cb5-199" aria-hidden="true" tabindex="-1"></a>wasting some of the probability mass in the relevant $Q$</span>
<span id="cb5-200"><a href="#cb5-200" aria-hidden="true" tabindex="-1"></a>distributions. In other words, the SNE cost function focuses on</span>
<span id="cb5-201"><a href="#cb5-201" aria-hidden="true" tabindex="-1"></a>retaining the local structure of the data in the map (for reasonable</span>
<span id="cb5-202"><a href="#cb5-202" aria-hidden="true" tabindex="-1"></a>values of the variance of the Gaussian in the high-dimensional space,</span>
<span id="cb5-203"><a href="#cb5-203" aria-hidden="true" tabindex="-1"></a>$\sigma_i$).</span>
<span id="cb5-204"><a href="#cb5-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-205"><a href="#cb5-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-206"><a href="#cb5-206" aria-hidden="true" tabindex="-1"></a>The remaining parameter to be selected the variance $\sigma_i$ of the Gaussian</span>
<span id="cb5-207"><a href="#cb5-207" aria-hidden="true" tabindex="-1"></a>that is centered over each high-dimensional datapoint, $x_i$.</span>
<span id="cb5-208"><a href="#cb5-208" aria-hidden="true" tabindex="-1"></a>It is not likely that there is a single value of $\sigma_i$ that is optimal</span>
<span id="cb5-209"><a href="#cb5-209" aria-hidden="true" tabindex="-1"></a>for all datapoints in the data set because the density of the data is likely</span>
<span id="cb5-210"><a href="#cb5-210" aria-hidden="true" tabindex="-1"></a>to vary. In dense regions, a smaller value of $\sigma_i$ is usually more</span>
<span id="cb5-211"><a href="#cb5-211" aria-hidden="true" tabindex="-1"></a>appropriate than in sparser regions. Any particular value of $\sigma_i$</span>
<span id="cb5-212"><a href="#cb5-212" aria-hidden="true" tabindex="-1"></a>induces a probability distribution, $P_i$, over all of the other datapoints.</span>
<span id="cb5-213"><a href="#cb5-213" aria-hidden="true" tabindex="-1"></a>This distribution has an entropy which increases as $\sigma_i$ increases. SNE</span>
<span id="cb5-214"><a href="#cb5-214" aria-hidden="true" tabindex="-1"></a>performs a binary search for the value of $\sigma_i$ that produces a $P_i$</span>
<span id="cb5-215"><a href="#cb5-215" aria-hidden="true" tabindex="-1"></a>with a fixed perplexity that is specified by the user<span class="ot">[^perplexity]</span>. The</span>
<span id="cb5-216"><a href="#cb5-216" aria-hidden="true" tabindex="-1"></a>perplexity is defined as</span>
<span id="cb5-217"><a href="#cb5-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-218"><a href="#cb5-218" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-219"><a href="#cb5-219" aria-hidden="true" tabindex="-1"></a>Perp(P_i) = 2^{H(P_i)}\,,</span>
<span id="cb5-220"><a href="#cb5-220" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-221"><a href="#cb5-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-222"><a href="#cb5-222" aria-hidden="true" tabindex="-1"></a>where $H(P_i)$ is the Shannon entropy of $P_i$ measured in bits</span>
<span id="cb5-223"><a href="#cb5-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-224"><a href="#cb5-224" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-225"><a href="#cb5-225" aria-hidden="true" tabindex="-1"></a>H(P_i) = - \sum_j p_{j|i} \log_2 p_{j|i}\,.</span>
<span id="cb5-226"><a href="#cb5-226" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-227"><a href="#cb5-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-228"><a href="#cb5-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-229"><a href="#cb5-229" aria-hidden="true" tabindex="-1"></a><span class="ot">[^perplexity]: </span>Note that the perplexity increases monotonically with the variance</span>
<span id="cb5-230"><a href="#cb5-230" aria-hidden="true" tabindex="-1"></a>  $\sigma_i$.</span>
<span id="cb5-231"><a href="#cb5-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-232"><a href="#cb5-232" aria-hidden="true" tabindex="-1"></a>The perplexity can be interpreted as a smooth measure of the effective number</span>
<span id="cb5-233"><a href="#cb5-233" aria-hidden="true" tabindex="-1"></a>of neighbors. The performance of SNE is fairly robust to changes in the</span>
<span id="cb5-234"><a href="#cb5-234" aria-hidden="true" tabindex="-1"></a>perplexity, and typical values are between 5 and 50.</span>
<span id="cb5-235"><a href="#cb5-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-236"><a href="#cb5-236" aria-hidden="true" tabindex="-1"></a>The minimization of the cost function in @eq-sne_cost_function is</span>
<span id="cb5-237"><a href="#cb5-237" aria-hidden="true" tabindex="-1"></a>performed using a gradient descent method. The gradient has a surprisingly</span>
<span id="cb5-238"><a href="#cb5-238" aria-hidden="true" tabindex="-1"></a>simple form</span>
<span id="cb5-239"><a href="#cb5-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-240"><a href="#cb5-240" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-241"><a href="#cb5-241" aria-hidden="true" tabindex="-1"></a>\frac{\partial C}{\partial y_i} = 2 \sum_j (p_{j|i} - q_{j|i} + p_{i|j} -</span>
<span id="cb5-242"><a href="#cb5-242" aria-hidden="true" tabindex="-1"></a>q_{i|j})(y_i - y_j)\,.</span>
<span id="cb5-243"><a href="#cb5-243" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-244"><a href="#cb5-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-245"><a href="#cb5-245" aria-hidden="true" tabindex="-1"></a>Physically, the gradient may be interpreted as the resultant force created by</span>
<span id="cb5-246"><a href="#cb5-246" aria-hidden="true" tabindex="-1"></a>a set of springs between the map point $y_i$ and all other map points $y_j$.</span>
<span id="cb5-247"><a href="#cb5-247" aria-hidden="true" tabindex="-1"></a>All springs exert a force along the direction $(y_i - y_j)$. The spring</span>
<span id="cb5-248"><a href="#cb5-248" aria-hidden="true" tabindex="-1"></a>between $y_i$ and $y_j$ repels or attracts the map points depending on whether</span>
<span id="cb5-249"><a href="#cb5-249" aria-hidden="true" tabindex="-1"></a>the distance between the two in the map is too small or too large to represent</span>
<span id="cb5-250"><a href="#cb5-250" aria-hidden="true" tabindex="-1"></a>the similarities between the two high-dimensional datapoints. The force</span>
<span id="cb5-251"><a href="#cb5-251" aria-hidden="true" tabindex="-1"></a>exerted by the spring between $y_i$ and $y_j$ is proportional to its length,</span>
<span id="cb5-252"><a href="#cb5-252" aria-hidden="true" tabindex="-1"></a>and also proportional to its stiffness, which is the mismatch $(p_{j|i} -</span>
<span id="cb5-253"><a href="#cb5-253" aria-hidden="true" tabindex="-1"></a>q_{j|i} + p_{i|j} + q_{i|j})$ between the pairwise similarities of the data</span>
<span id="cb5-254"><a href="#cb5-254" aria-hidden="true" tabindex="-1"></a>points.</span>
<span id="cb5-255"><a href="#cb5-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-256"><a href="#cb5-256" aria-hidden="true" tabindex="-1"></a>The gradient descent is initialized by sampling map points randomly from an</span>
<span id="cb5-257"><a href="#cb5-257" aria-hidden="true" tabindex="-1"></a>isotropic Gaussian with small variance that is centered around the origin. In</span>
<span id="cb5-258"><a href="#cb5-258" aria-hidden="true" tabindex="-1"></a>order to speed up the optimization and to avoid poor local minima, a</span>
<span id="cb5-259"><a href="#cb5-259" aria-hidden="true" tabindex="-1"></a>relatively large momentum term is added to the gradient. In other words, the</span>
<span id="cb5-260"><a href="#cb5-260" aria-hidden="true" tabindex="-1"></a>current gradient is added to an exponentially decaying sum of previous</span>
<span id="cb5-261"><a href="#cb5-261" aria-hidden="true" tabindex="-1"></a>gradients in order to determine the changes in the coordinates of the map</span>
<span id="cb5-262"><a href="#cb5-262" aria-hidden="true" tabindex="-1"></a>points at each iteration of the gradient search. Mathematically, the gradient</span>
<span id="cb5-263"><a href="#cb5-263" aria-hidden="true" tabindex="-1"></a>update with a momentum term is given by</span>
<span id="cb5-264"><a href="#cb5-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-265"><a href="#cb5-265" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-266"><a href="#cb5-266" aria-hidden="true" tabindex="-1"></a>\mathcal{Y}^{(t)} = \mathcal{Y}^{(t-1)} + \eta \frac{\partial C}{\partial</span>
<span id="cb5-267"><a href="#cb5-267" aria-hidden="true" tabindex="-1"></a>\mathcal{Y}} + \alpha(t) \left( \mathcal{Y}^{(t-1)} - \mathcal{Y}^{(t-2)}\right)\,,</span>
<span id="cb5-268"><a href="#cb5-268" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-269"><a href="#cb5-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-270"><a href="#cb5-270" aria-hidden="true" tabindex="-1"></a>where $\mathcal{Y}^{(t)}$ indicates the solution at iteration $t$, $\eta$</span>
<span id="cb5-271"><a href="#cb5-271" aria-hidden="true" tabindex="-1"></a>indicates the learning rate, and $\alpha(t)$ represents the momentum at</span>
<span id="cb5-272"><a href="#cb5-272" aria-hidden="true" tabindex="-1"></a>iteration $t$.</span>
<span id="cb5-273"><a href="#cb5-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-274"><a href="#cb5-274" aria-hidden="true" tabindex="-1"></a>In addition, in the early stages of the optimization, Gaussian noise is added</span>
<span id="cb5-275"><a href="#cb5-275" aria-hidden="true" tabindex="-1"></a>to the map points after each iteration. Gradually reducing the variance of</span>
<span id="cb5-276"><a href="#cb5-276" aria-hidden="true" tabindex="-1"></a>this noise performs a type of simulated annealing that helps the optimization</span>
<span id="cb5-277"><a href="#cb5-277" aria-hidden="true" tabindex="-1"></a>to escape from poor local minima in the cost function. If the variance of the</span>
<span id="cb5-278"><a href="#cb5-278" aria-hidden="true" tabindex="-1"></a>noise changes very slowly at the critical point at which the global structure</span>
<span id="cb5-279"><a href="#cb5-279" aria-hidden="true" tabindex="-1"></a>of the map starts to form, SNE tends to find maps with a better global</span>
<span id="cb5-280"><a href="#cb5-280" aria-hidden="true" tabindex="-1"></a>organization. Unfortunately, this requires sensible choices of the initial</span>
<span id="cb5-281"><a href="#cb5-281" aria-hidden="true" tabindex="-1"></a>amount of Gaussian noise and the rate at which it decays. Moreover, these</span>
<span id="cb5-282"><a href="#cb5-282" aria-hidden="true" tabindex="-1"></a>choices interact with the amount of momentum and the step size that are</span>
<span id="cb5-283"><a href="#cb5-283" aria-hidden="true" tabindex="-1"></a>employed in the gradient descent. It is therefore common to run the</span>
<span id="cb5-284"><a href="#cb5-284" aria-hidden="true" tabindex="-1"></a>optimization several times on a data set to find appropriate values for the</span>
<span id="cb5-285"><a href="#cb5-285" aria-hidden="true" tabindex="-1"></a>parameters.<span class="ot">[^global_optimization]</span> In this respect, SNE is inferior to methods</span>
<span id="cb5-286"><a href="#cb5-286" aria-hidden="true" tabindex="-1"></a>that allow convex optimization and it would be useful to find an optimization</span>
<span id="cb5-287"><a href="#cb5-287" aria-hidden="true" tabindex="-1"></a>method that gives good results without requiring the extra computation time</span>
<span id="cb5-288"><a href="#cb5-288" aria-hidden="true" tabindex="-1"></a>and parameter choices introduced by the simulated annealing.</span>
<span id="cb5-289"><a href="#cb5-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-290"><a href="#cb5-290" aria-hidden="true" tabindex="-1"></a><span class="ot">[^global_optimization]: </span>Picking the best map after several runs as</span>
<span id="cb5-291"><a href="#cb5-291" aria-hidden="true" tabindex="-1"></a>  visualization of the data is not nearly as problematic as picking the model</span>
<span id="cb5-292"><a href="#cb5-292" aria-hidden="true" tabindex="-1"></a>  that does best on a test set during supervised learning. In visualization,</span>
<span id="cb5-293"><a href="#cb5-293" aria-hidden="true" tabindex="-1"></a>  the aim is to see the structure in the training data, not to generalize to</span>
<span id="cb5-294"><a href="#cb5-294" aria-hidden="true" tabindex="-1"></a>  held out test data.</span>
<span id="cb5-295"><a href="#cb5-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-296"><a href="#cb5-296" aria-hidden="true" tabindex="-1"></a><span class="fu"># t-Distributed Stochastic Neighbor Embedding {#sec-tsne}</span></span>
<span id="cb5-297"><a href="#cb5-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-298"><a href="#cb5-298" aria-hidden="true" tabindex="-1"></a>@sec-sne discussed SNE as it was presented by</span>
<span id="cb5-299"><a href="#cb5-299" aria-hidden="true" tabindex="-1"></a>@hinton:stochastic. Although SNE constructs reasonably good</span>
<span id="cb5-300"><a href="#cb5-300" aria-hidden="true" tabindex="-1"></a>visualizations, it is hampered by a cost function that is difficult to</span>
<span id="cb5-301"><a href="#cb5-301" aria-hidden="true" tabindex="-1"></a>optimize and by a problem we refer to as the "crowding problem." In this</span>
<span id="cb5-302"><a href="#cb5-302" aria-hidden="true" tabindex="-1"></a>section, we present a new technique called "t-Distributed Stochastic Neighbor</span>
<span id="cb5-303"><a href="#cb5-303" aria-hidden="true" tabindex="-1"></a>Embedding" or "t-SNE" that aims to alleviate these problems. The cost</span>
<span id="cb5-304"><a href="#cb5-304" aria-hidden="true" tabindex="-1"></a>function used by t-SNE differs from the one used by SNE in two ways: (1) it</span>
<span id="cb5-305"><a href="#cb5-305" aria-hidden="true" tabindex="-1"></a>uses a symmetrized version of the SNE cost function with simpler gradients</span>
<span id="cb5-306"><a href="#cb5-306" aria-hidden="true" tabindex="-1"></a>that was briefly introduced by @cook:visualizing and (2) it uses a</span>
<span id="cb5-307"><a href="#cb5-307" aria-hidden="true" tabindex="-1"></a>Student-t distribution rather than a Gaussian to compute the similarity</span>
<span id="cb5-308"><a href="#cb5-308" aria-hidden="true" tabindex="-1"></a>between two points *in the low dimensional space*. t-SNE employs a</span>
<span id="cb5-309"><a href="#cb5-309" aria-hidden="true" tabindex="-1"></a>heavy-tailed distribution in the low-dimensional space to alleviate both the</span>
<span id="cb5-310"><a href="#cb5-310" aria-hidden="true" tabindex="-1"></a>crowding problem and the optimization problems of SNE.</span>
<span id="cb5-311"><a href="#cb5-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-312"><a href="#cb5-312" aria-hidden="true" tabindex="-1"></a>In this section, we first discuss the symmetric version of SNE (@sec-symmetric_sne).</span>
<span id="cb5-313"><a href="#cb5-313" aria-hidden="true" tabindex="-1"></a>Subsequently, we discuss the crowding problem</span>
<span id="cb5-314"><a href="#cb5-314" aria-hidden="true" tabindex="-1"></a>(@sec-crowding), and the use of heavy-tailed distributions to</span>
<span id="cb5-315"><a href="#cb5-315" aria-hidden="true" tabindex="-1"></a>address this problem (@sec-heavy_tail). We conclude the</span>
<span id="cb5-316"><a href="#cb5-316" aria-hidden="true" tabindex="-1"></a> by describing our approach to the optimization of the t-SNE cost</span>
<span id="cb5-317"><a href="#cb5-317" aria-hidden="true" tabindex="-1"></a>function (@sec-optimization_methods_for_tsne).</span>
<span id="cb5-318"><a href="#cb5-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-319"><a href="#cb5-319" aria-hidden="true" tabindex="-1"></a><span class="fu">## Symmetric SNE {#sec-symmetric_sne}</span></span>
<span id="cb5-320"><a href="#cb5-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-321"><a href="#cb5-321" aria-hidden="true" tabindex="-1"></a>As an alternative to minimizing the sum of the Kullback-Leibler divergences</span>
<span id="cb5-322"><a href="#cb5-322" aria-hidden="true" tabindex="-1"></a>between the conditional probabilities $p_{j|i}$ and $q_{j|i}$, it is also</span>
<span id="cb5-323"><a href="#cb5-323" aria-hidden="true" tabindex="-1"></a>possible to minimize a single Kullback-Leibler divergence between a joint</span>
<span id="cb5-324"><a href="#cb5-324" aria-hidden="true" tabindex="-1"></a>probability distribution, $P$, in the high-dimensional space and a joint</span>
<span id="cb5-325"><a href="#cb5-325" aria-hidden="true" tabindex="-1"></a>probability distribution, $Q$, in the low-dimensional space:</span>
<span id="cb5-326"><a href="#cb5-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-327"><a href="#cb5-327" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-328"><a href="#cb5-328" aria-hidden="true" tabindex="-1"></a>C = KL(P\|Q) = \sum_i \sum_j p_{ij} \log \frac{p_{ij}}{q_{ij}}\,,</span>
<span id="cb5-329"><a href="#cb5-329" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-330"><a href="#cb5-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-331"><a href="#cb5-331" aria-hidden="true" tabindex="-1"></a>where again, we set $p_{ij}$ and $q_{ii}$ to zero. We refer to this type of</span>
<span id="cb5-332"><a href="#cb5-332" aria-hidden="true" tabindex="-1"></a>SNE as symmetric SNE, because it has the property that $p_{ij} = p_{ji}$ and</span>
<span id="cb5-333"><a href="#cb5-333" aria-hidden="true" tabindex="-1"></a>$q_{ij} = q_{ji}$ for all $i, j$. In symmetric SNE, the pairwise</span>
<span id="cb5-334"><a href="#cb5-334" aria-hidden="true" tabindex="-1"></a>similarities in the low-dimensional map $q_{ij}$ are given by</span>
<span id="cb5-335"><a href="#cb5-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-336"><a href="#cb5-336" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-337"><a href="#cb5-337" aria-hidden="true" tabindex="-1"></a>q_{ij} = \frac{\exp(-\|x_i - x_j\|^2)}{\sum_{k\neq l} \exp(-\|x_k -</span>
<span id="cb5-338"><a href="#cb5-338" aria-hidden="true" tabindex="-1"></a>x_l\|^2)}\,.</span>
<span id="cb5-339"><a href="#cb5-339" aria-hidden="true" tabindex="-1"></a>$$ {#eq-pairwise_similarities}</span>
<span id="cb5-340"><a href="#cb5-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-341"><a href="#cb5-341" aria-hidden="true" tabindex="-1"></a>The obvious way to define the pairwise similarities in the high-dimensional</span>
<span id="cb5-342"><a href="#cb5-342" aria-hidden="true" tabindex="-1"></a>space $p_{ij}$ is</span>
<span id="cb5-343"><a href="#cb5-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-344"><a href="#cb5-344" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-345"><a href="#cb5-345" aria-hidden="true" tabindex="-1"></a>p_{ij} = \frac{\exp(-\|x_i - x_j\|^2/2\sigma^2)}{\sum_{k\neq l} \exp(-\|x_k -</span>
<span id="cb5-346"><a href="#cb5-346" aria-hidden="true" tabindex="-1"></a>x_l\|^2/2\sigma^2)}\,</span>
<span id="cb5-347"><a href="#cb5-347" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-348"><a href="#cb5-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-349"><a href="#cb5-349" aria-hidden="true" tabindex="-1"></a>but this causes problems when a high-dimensional datapoint $x_i$ is an outlier</span>
<span id="cb5-350"><a href="#cb5-350" aria-hidden="true" tabindex="-1"></a>(i.e., all pairwise distances $\|x_i - x_j\|^2$ are large for $x_i$). For such</span>
<span id="cb5-351"><a href="#cb5-351" aria-hidden="true" tabindex="-1"></a>an outlier, the values of $p_{ij}$ are extremely small for all $j$, so the</span>
<span id="cb5-352"><a href="#cb5-352" aria-hidden="true" tabindex="-1"></a>location of its low-dimensional map point $y_i$ has very little effect on the</span>
<span id="cb5-353"><a href="#cb5-353" aria-hidden="true" tabindex="-1"></a>cost function. As a result, the position of the map point is not well</span>
<span id="cb5-354"><a href="#cb5-354" aria-hidden="true" tabindex="-1"></a>determined by the positions of the other map points. We circumvent this</span>
<span id="cb5-355"><a href="#cb5-355" aria-hidden="true" tabindex="-1"></a>problem by defining the joint probabilities $p_{ij}$ in the high dimensional</span>
<span id="cb5-356"><a href="#cb5-356" aria-hidden="true" tabindex="-1"></a>space to be symmetrized conditional probabilities, that is, we set $p_{ij} =</span>
<span id="cb5-357"><a href="#cb5-357" aria-hidden="true" tabindex="-1"></a>\frac{p_{j|i} + p_{i|j}}{2n}$. This ensures that $\sum_j p_{ij} &gt;</span>
<span id="cb5-358"><a href="#cb5-358" aria-hidden="true" tabindex="-1"></a>\frac{1}{2n}$ for all datapoints $x_i$, as a result of which each datapoint</span>
<span id="cb5-359"><a href="#cb5-359" aria-hidden="true" tabindex="-1"></a>$x_i$ makes a significant contribution to the cost function. In the</span>
<span id="cb5-360"><a href="#cb5-360" aria-hidden="true" tabindex="-1"></a>low-dimensional space, symmetric SNE simply uses @eq-pairwise_similarities. </span>
<span id="cb5-361"><a href="#cb5-361" aria-hidden="true" tabindex="-1"></a>The main advantage of the symmetric version of</span>
<span id="cb5-362"><a href="#cb5-362" aria-hidden="true" tabindex="-1"></a>SNE is the simpler form of its gradient, which is faster to compute. The</span>
<span id="cb5-363"><a href="#cb5-363" aria-hidden="true" tabindex="-1"></a>gradient of symmetric SNE is fairly similar to that of asymmetric SNE, and is</span>
<span id="cb5-364"><a href="#cb5-364" aria-hidden="true" tabindex="-1"></a>given by</span>
<span id="cb5-365"><a href="#cb5-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-366"><a href="#cb5-366" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-367"><a href="#cb5-367" aria-hidden="true" tabindex="-1"></a>\frac{\partial C}{\partial y_i} = 4 \sum_j (p_{ij} - q_{ij})(y_i - y_j)\,.</span>
<span id="cb5-368"><a href="#cb5-368" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-369"><a href="#cb5-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-370"><a href="#cb5-370" aria-hidden="true" tabindex="-1"></a>In preliminary experiments, we observed that symmetric SNE seems to produce</span>
<span id="cb5-371"><a href="#cb5-371" aria-hidden="true" tabindex="-1"></a>maps that are just as good as asymmetric SNE, and sometimes even a little</span>
<span id="cb5-372"><a href="#cb5-372" aria-hidden="true" tabindex="-1"></a>better.</span>
<span id="cb5-373"><a href="#cb5-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-374"><a href="#cb5-374" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Crowding Problem {#sec-crowding}</span></span>
<span id="cb5-375"><a href="#cb5-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-376"><a href="#cb5-376" aria-hidden="true" tabindex="-1"></a>Consider a set of datapoints that lie on a two-dimensional curved manifold</span>
<span id="cb5-377"><a href="#cb5-377" aria-hidden="true" tabindex="-1"></a>which is approximately linear on a small scale, and which is embedded within a</span>
<span id="cb5-378"><a href="#cb5-378" aria-hidden="true" tabindex="-1"></a>higher-dimensional space. It is possible to model the small pairwise distances</span>
<span id="cb5-379"><a href="#cb5-379" aria-hidden="true" tabindex="-1"></a>between datapoints fairly well in a two-dimensional map, which is often</span>
<span id="cb5-380"><a href="#cb5-380" aria-hidden="true" tabindex="-1"></a>illustrated on toy examples such as the "Swiss roll" data set. Now suppose that</span>
<span id="cb5-381"><a href="#cb5-381" aria-hidden="true" tabindex="-1"></a>the manifold has ten intrinsic dimensions<span class="ot">[^dataset]</span> and is embedded within a</span>
<span id="cb5-382"><a href="#cb5-382" aria-hidden="true" tabindex="-1"></a>space of much higher dimensionality. There are several reasons why the</span>
<span id="cb5-383"><a href="#cb5-383" aria-hidden="true" tabindex="-1"></a>pairwise distances in a two-dimensional map cannot faithfully model distances</span>
<span id="cb5-384"><a href="#cb5-384" aria-hidden="true" tabindex="-1"></a>between points on the ten-dimensional manifold. For instance, in ten</span>
<span id="cb5-385"><a href="#cb5-385" aria-hidden="true" tabindex="-1"></a>dimensions, it is possible to have 11 datapoints that are mutually</span>
<span id="cb5-386"><a href="#cb5-386" aria-hidden="true" tabindex="-1"></a>equidistant and there is no way to model this faithfully in a two-dimensional</span>
<span id="cb5-387"><a href="#cb5-387" aria-hidden="true" tabindex="-1"></a>map. A related problem is the very different distribution of pairwise</span>
<span id="cb5-388"><a href="#cb5-388" aria-hidden="true" tabindex="-1"></a>distances in the two spaces. The volume of a sphere centered on datapoint $i$</span>
<span id="cb5-389"><a href="#cb5-389" aria-hidden="true" tabindex="-1"></a>scales as $r^m$, where $r$ is the radius and $m$ the dimensionality of the</span>
<span id="cb5-390"><a href="#cb5-390" aria-hidden="true" tabindex="-1"></a>sphere. So if the datapoints are approximately uniformly distributed in the</span>
<span id="cb5-391"><a href="#cb5-391" aria-hidden="true" tabindex="-1"></a>region around $i$ on the ten-dimensional manifold, we get the following</span>
<span id="cb5-392"><a href="#cb5-392" aria-hidden="true" tabindex="-1"></a>"crowding problem:" the area of the two-dimensional map that is available to</span>
<span id="cb5-393"><a href="#cb5-393" aria-hidden="true" tabindex="-1"></a>accommodate moderately distant datapoints will not be nearly large enough</span>
<span id="cb5-394"><a href="#cb5-394" aria-hidden="true" tabindex="-1"></a>compared with the area available to accommodate nearby datapoints. Hence, if we</span>
<span id="cb5-395"><a href="#cb5-395" aria-hidden="true" tabindex="-1"></a>want to model the small distances accurately in the map, most of the points</span>
<span id="cb5-396"><a href="#cb5-396" aria-hidden="true" tabindex="-1"></a>that are at a moderate distance from datapoint $i$ will have to be placed much</span>
<span id="cb5-397"><a href="#cb5-397" aria-hidden="true" tabindex="-1"></a>too far away in the two-dimensional map. In SNE, the spring connecting</span>
<span id="cb5-398"><a href="#cb5-398" aria-hidden="true" tabindex="-1"></a>datapoint $i$ to each of these too-distant map points will thus exert a very</span>
<span id="cb5-399"><a href="#cb5-399" aria-hidden="true" tabindex="-1"></a>small attractive force. Although these attractive forces are very small, the</span>
<span id="cb5-400"><a href="#cb5-400" aria-hidden="true" tabindex="-1"></a>very large number of such forces crushes together the points in the center of</span>
<span id="cb5-401"><a href="#cb5-401" aria-hidden="true" tabindex="-1"></a>the map, which prevents gaps from forming between the natural clusters. Note</span>
<span id="cb5-402"><a href="#cb5-402" aria-hidden="true" tabindex="-1"></a>that the crowding problem is not specific to SNE, but that it occurs in other</span>
<span id="cb5-403"><a href="#cb5-403" aria-hidden="true" tabindex="-1"></a>local techniques for multidimensional scaling such as Sammon mapping.</span>
<span id="cb5-404"><a href="#cb5-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-405"><a href="#cb5-405" aria-hidden="true" tabindex="-1"></a>An attempt to address the crowding problem by adding a slight repulsion to all</span>
<span id="cb5-406"><a href="#cb5-406" aria-hidden="true" tabindex="-1"></a>springs was presented by @cook:visualizing. The slight repulsion is</span>
<span id="cb5-407"><a href="#cb5-407" aria-hidden="true" tabindex="-1"></a>created by introducing a uniform background model with a small mixing</span>
<span id="cb5-408"><a href="#cb5-408" aria-hidden="true" tabindex="-1"></a>proportion, $\rho$. So however far apart two map points are, $q_{ij}$ can</span>
<span id="cb5-409"><a href="#cb5-409" aria-hidden="true" tabindex="-1"></a>never fall below $\frac{2\rho}{n(n-1)}$ (because the uniform background</span>
<span id="cb5-410"><a href="#cb5-410" aria-hidden="true" tabindex="-1"></a>distribution is over $n(n-1)/2$ pairs). As a result, for datapoints that are</span>
<span id="cb5-411"><a href="#cb5-411" aria-hidden="true" tabindex="-1"></a>far apart in the high-dimensional space, $q_{ij}$ will always be larger than</span>
<span id="cb5-412"><a href="#cb5-412" aria-hidden="true" tabindex="-1"></a>$p_{ij}$, leading to a slight repulsion. This technique is called UNI-SNE and</span>
<span id="cb5-413"><a href="#cb5-413" aria-hidden="true" tabindex="-1"></a>although it usually outperforms standard SNE, the optimization of the UNI-SNE</span>
<span id="cb5-414"><a href="#cb5-414" aria-hidden="true" tabindex="-1"></a>cost function is tedious. The best optimization method known is to start by</span>
<span id="cb5-415"><a href="#cb5-415" aria-hidden="true" tabindex="-1"></a>setting the background mixing proportion to zero (i.e., by performing standard</span>
<span id="cb5-416"><a href="#cb5-416" aria-hidden="true" tabindex="-1"></a>SNE). Once the SNE cost function has been optimized using simulated annealing,</span>
<span id="cb5-417"><a href="#cb5-417" aria-hidden="true" tabindex="-1"></a>the background mixing proportion can be increased to allow some gaps to form</span>
<span id="cb5-418"><a href="#cb5-418" aria-hidden="true" tabindex="-1"></a>between natural clusters as shown by @cook:visualizing. Optimizing the</span>
<span id="cb5-419"><a href="#cb5-419" aria-hidden="true" tabindex="-1"></a>UNI-SNE cost function directly does not work because two map points that are</span>
<span id="cb5-420"><a href="#cb5-420" aria-hidden="true" tabindex="-1"></a>far apart will get almost all of their $q_{i}$ from the uniform background. So</span>
<span id="cb5-421"><a href="#cb5-421" aria-hidden="true" tabindex="-1"></a>even if their $p_{ij}$ is large, there will be no attractive force between</span>
<span id="cb5-422"><a href="#cb5-422" aria-hidden="true" tabindex="-1"></a>them, because a small change in their separation will have a vanishingly small</span>
<span id="cb5-423"><a href="#cb5-423" aria-hidden="true" tabindex="-1"></a>*proportional* effect on $q_{ij}$. This means that if two parts of a cluster</span>
<span id="cb5-424"><a href="#cb5-424" aria-hidden="true" tabindex="-1"></a>get separated early on in the optimization, there is no force to pull them</span>
<span id="cb5-425"><a href="#cb5-425" aria-hidden="true" tabindex="-1"></a>back together.</span>
<span id="cb5-426"><a href="#cb5-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-427"><a href="#cb5-427" aria-hidden="true" tabindex="-1"></a><span class="fu">## Mismatched tails can compensate for mismatched dimensionalities {#sec-heavy_tail}</span></span>
<span id="cb5-428"><a href="#cb5-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-429"><a href="#cb5-429" aria-hidden="true" tabindex="-1"></a>Since symmetric SNE is actually matching the joint probabilities of pairs of</span>
<span id="cb5-430"><a href="#cb5-430" aria-hidden="true" tabindex="-1"></a>datapoints in the high-dimensional and the low-dimensional spaces rather than</span>
<span id="cb5-431"><a href="#cb5-431" aria-hidden="true" tabindex="-1"></a>their distances, we have a natural way of alleviating the crowing problem that</span>
<span id="cb5-432"><a href="#cb5-432" aria-hidden="true" tabindex="-1"></a>works as follows. In the high-dimensional space, we convert distances into</span>
<span id="cb5-433"><a href="#cb5-433" aria-hidden="true" tabindex="-1"></a>probabilities using a Gaussian distribution. In the low-dimensional map, we</span>
<span id="cb5-434"><a href="#cb5-434" aria-hidden="true" tabindex="-1"></a>can use a probability distribution that has a much heavier tails than a</span>
<span id="cb5-435"><a href="#cb5-435" aria-hidden="true" tabindex="-1"></a>Gaussian to convert distances into probabilities. This allows a moderate</span>
<span id="cb5-436"><a href="#cb5-436" aria-hidden="true" tabindex="-1"></a>distance in the high-dimensional space to be faithfully modeled by a much</span>
<span id="cb5-437"><a href="#cb5-437" aria-hidden="true" tabindex="-1"></a>larger distance in the map and, as a result, it eliminates the unwanted</span>
<span id="cb5-438"><a href="#cb5-438" aria-hidden="true" tabindex="-1"></a>attractive forces between map points that represent moderately dissimilar</span>
<span id="cb5-439"><a href="#cb5-439" aria-hidden="true" tabindex="-1"></a>datapoints.</span>
<span id="cb5-440"><a href="#cb5-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-441"><a href="#cb5-441" aria-hidden="true" tabindex="-1"></a>In t-SNE, we employ a Student $t$-distribution with a single degree of</span>
<span id="cb5-442"><a href="#cb5-442" aria-hidden="true" tabindex="-1"></a>freedom (which is the same as a Cauchy distribution) as the heavy-tailed</span>
<span id="cb5-443"><a href="#cb5-443" aria-hidden="true" tabindex="-1"></a>distribution in the low-dimensional map.  Using this distribution, the joint</span>
<span id="cb5-444"><a href="#cb5-444" aria-hidden="true" tabindex="-1"></a>probabilities $q_{ij}$ are defined as</span>
<span id="cb5-445"><a href="#cb5-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-446"><a href="#cb5-446" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-447"><a href="#cb5-447" aria-hidden="true" tabindex="-1"></a>q_{ij} = \frac{(1+\|y_i - y_j\|^2)^{-1}}{\sum_{k \neq l}(1+\|y_k -</span>
<span id="cb5-448"><a href="#cb5-448" aria-hidden="true" tabindex="-1"></a>y_t\|^2)^{-1}}</span>
<span id="cb5-449"><a href="#cb5-449" aria-hidden="true" tabindex="-1"></a>$$ {#eq-joint_probabilities}</span>
<span id="cb5-450"><a href="#cb5-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-451"><a href="#cb5-451" aria-hidden="true" tabindex="-1"></a>We use a Student t-distribution with a single degree of freedom, because it</span>
<span id="cb5-452"><a href="#cb5-452" aria-hidden="true" tabindex="-1"></a>has the particularly nice property that $\left(1+\|y_i - y_j\|^2\right)^{-1}$</span>
<span id="cb5-453"><a href="#cb5-453" aria-hidden="true" tabindex="-1"></a>approaches an inverse square law for large pairwise distances $\|y_i - y_j\|$</span>
<span id="cb5-454"><a href="#cb5-454" aria-hidden="true" tabindex="-1"></a>in the low-dimensional map. This makes the map's representation of joint</span>
<span id="cb5-455"><a href="#cb5-455" aria-hidden="true" tabindex="-1"></a>probabilities (almost) invariant to changes in the scale of the map for map</span>
<span id="cb5-456"><a href="#cb5-456" aria-hidden="true" tabindex="-1"></a>points that are far apart. It also means that large clusters of points that</span>
<span id="cb5-457"><a href="#cb5-457" aria-hidden="true" tabindex="-1"></a>are far apart interact in just the same way as individual points, so the</span>
<span id="cb5-458"><a href="#cb5-458" aria-hidden="true" tabindex="-1"></a>optimization operates in the same way at all but the finest scales. A</span>
<span id="cb5-459"><a href="#cb5-459" aria-hidden="true" tabindex="-1"></a>theoretical justification for our selection of the Student $t$-distribution is</span>
<span id="cb5-460"><a href="#cb5-460" aria-hidden="true" tabindex="-1"></a>that it is closely related to the Gaussian distribution, as the Student</span>
<span id="cb5-461"><a href="#cb5-461" aria-hidden="true" tabindex="-1"></a>$t$-distribution is an infinite mixture of Gaussians. A computationally</span>
<span id="cb5-462"><a href="#cb5-462" aria-hidden="true" tabindex="-1"></a>convenient property is that it is much faster to evaluate the density of a</span>
<span id="cb5-463"><a href="#cb5-463" aria-hidden="true" tabindex="-1"></a>point under a Student $t$-distribution than under a Gaussian because it does</span>
<span id="cb5-464"><a href="#cb5-464" aria-hidden="true" tabindex="-1"></a>not involve an exponential, even though the Student $t$-distribution is</span>
<span id="cb5-465"><a href="#cb5-465" aria-hidden="true" tabindex="-1"></a>equivalent to an infinite mixture of Gaussians with different variances.</span>
<span id="cb5-466"><a href="#cb5-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-467"><a href="#cb5-467" aria-hidden="true" tabindex="-1"></a>The gradient of the Kullback-Leibler divergence between $P$ and the Student-$t$</span>
<span id="cb5-468"><a href="#cb5-468" aria-hidden="true" tabindex="-1"></a>based joint probability distribution $Q$ (computed using @eq-joint_probabilities)</span>
<span id="cb5-469"><a href="#cb5-469" aria-hidden="true" tabindex="-1"></a>is derived in Appendix A, and is given by</span>
<span id="cb5-470"><a href="#cb5-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-471"><a href="#cb5-471" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-472"><a href="#cb5-472" aria-hidden="true" tabindex="-1"></a>\frac{\partial C}{\partial y_i} = 4 \sum_j (p_{ij} - q_{ij})(y_i -</span>
<span id="cb5-473"><a href="#cb5-473" aria-hidden="true" tabindex="-1"></a>y_j)(1+\|y_i - y_j\|^2)^{-1}\,.</span>
<span id="cb5-474"><a href="#cb5-474" aria-hidden="true" tabindex="-1"></a>$$ {#eq-gradient-tsne}</span>
<span id="cb5-475"><a href="#cb5-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-476"><a href="#cb5-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-477"><a href="#cb5-477" aria-hidden="true" tabindex="-1"></a>![Gradients of three types of SNE as a function of the pairwise Euclidean</span>
<span id="cb5-478"><a href="#cb5-478" aria-hidden="true" tabindex="-1"></a>distance between two points in the high-dimensional and the pairwise distance</span>
<span id="cb5-479"><a href="#cb5-479" aria-hidden="true" tabindex="-1"></a>between the points in the low-dimensional data representation.](figures/gradients.png){#fig-gradients}</span>
<span id="cb5-480"><a href="#cb5-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-481"><a href="#cb5-481" aria-hidden="true" tabindex="-1"></a>In @fig-gradients, we show the gradients between the</span>
<span id="cb5-482"><a href="#cb5-482" aria-hidden="true" tabindex="-1"></a>low-dimensional datapoints $y_i$ and $y_j$ as a function of their</span>
<span id="cb5-483"><a href="#cb5-483" aria-hidden="true" tabindex="-1"></a>pairwise Euclidean distances in the high-dimensional and the</span>
<span id="cb5-484"><a href="#cb5-484" aria-hidden="true" tabindex="-1"></a>low-dimensional space (i.e., as a function of $\|x_i-x_j\|$ and</span>
<span id="cb5-485"><a href="#cb5-485" aria-hidden="true" tabindex="-1"></a>$\|y_i-y_j\|$) for the symmetric versions of SNE, UNI-SNE, and</span>
<span id="cb5-486"><a href="#cb5-486" aria-hidden="true" tabindex="-1"></a>t-SNE. In the figures, positive values of the gradient represent an</span>
<span id="cb5-487"><a href="#cb5-487" aria-hidden="true" tabindex="-1"></a>attraction between the low-dimensional datapoints $y_i$ and $y_j$,</span>
<span id="cb5-488"><a href="#cb5-488" aria-hidden="true" tabindex="-1"></a>whereas negative values represent a repulsion between the two</span>
<span id="cb5-489"><a href="#cb5-489" aria-hidden="true" tabindex="-1"></a>datapoints. From the figures, we observe two main advantages of the</span>
<span id="cb5-490"><a href="#cb5-490" aria-hidden="true" tabindex="-1"></a>t-SNE gradient over the gradients of SNE and UNI-SNE.</span>
<span id="cb5-491"><a href="#cb5-491" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-492"><a href="#cb5-492" aria-hidden="true" tabindex="-1"></a>First, the t-SNE gradient strongly repels dissimilar datapoints that are</span>
<span id="cb5-493"><a href="#cb5-493" aria-hidden="true" tabindex="-1"></a>modeled by a small pairwise distance in the low-dimensional representation.</span>
<span id="cb5-494"><a href="#cb5-494" aria-hidden="true" tabindex="-1"></a>SNE has such repulsion as well, but its effect is minimal compared to the</span>
<span id="cb5-495"><a href="#cb5-495" aria-hidden="true" tabindex="-1"></a>strong attractions elsewhere in the gradient (the largest attraction in our</span>
<span id="cb5-496"><a href="#cb5-496" aria-hidden="true" tabindex="-1"></a>graphical representation of the gradient is approximately 19, whereas the</span>
<span id="cb5-497"><a href="#cb5-497" aria-hidden="true" tabindex="-1"></a>largest repulsion is approximately 1). In UNI-SNE, the amount of repulsion</span>
<span id="cb5-498"><a href="#cb5-498" aria-hidden="true" tabindex="-1"></a>between dissimilar datapoints is slightly larger, however, this repulsion is</span>
<span id="cb5-499"><a href="#cb5-499" aria-hidden="true" tabindex="-1"></a>only strong when the pairwise distance between the points in the</span>
<span id="cb5-500"><a href="#cb5-500" aria-hidden="true" tabindex="-1"></a>low-dimensional representation is already large (which is often not the case,</span>
<span id="cb5-501"><a href="#cb5-501" aria-hidden="true" tabindex="-1"></a>since the low-dimensional representation is initialized by sampling from a</span>
<span id="cb5-502"><a href="#cb5-502" aria-hidden="true" tabindex="-1"></a>Gaussian with a very small variance that is centered around the origin).</span>
<span id="cb5-503"><a href="#cb5-503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-504"><a href="#cb5-504" aria-hidden="true" tabindex="-1"></a>Second, although t-SNE introduces strong repulsions between dissimilar</span>
<span id="cb5-505"><a href="#cb5-505" aria-hidden="true" tabindex="-1"></a>datapoints that are modeled by small pairwise distances, these repulsions do</span>
<span id="cb5-506"><a href="#cb5-506" aria-hidden="true" tabindex="-1"></a>not go to infinity. In this respect, t-SNE differs from UNI-SNE, in which the</span>
<span id="cb5-507"><a href="#cb5-507" aria-hidden="true" tabindex="-1"></a>strength of the repulsion between very dissimilar datapoints is proportional</span>
<span id="cb5-508"><a href="#cb5-508" aria-hidden="true" tabindex="-1"></a>to their pairwise distance in the low-dimensional map, which may cause</span>
<span id="cb5-509"><a href="#cb5-509" aria-hidden="true" tabindex="-1"></a>dissimilar datapoints to move much too far away from each other.</span>
<span id="cb5-510"><a href="#cb5-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-511"><a href="#cb5-511" aria-hidden="true" tabindex="-1"></a>Taken together, t-SNE puts emphasis on (1) modeling dissimilar</span>
<span id="cb5-512"><a href="#cb5-512" aria-hidden="true" tabindex="-1"></a>datapoints by means of large pairwise distances, and (2) modeling</span>
<span id="cb5-513"><a href="#cb5-513" aria-hidden="true" tabindex="-1"></a>similar datapoints by means of small pairwise distances. Moreover, as</span>
<span id="cb5-514"><a href="#cb5-514" aria-hidden="true" tabindex="-1"></a>a result of these characteristics of the t-SNE cost function (and as a</span>
<span id="cb5-515"><a href="#cb5-515" aria-hidden="true" tabindex="-1"></a>result of the approximate scale invariance of the Student</span>
<span id="cb5-516"><a href="#cb5-516" aria-hidden="true" tabindex="-1"></a>t-distribution), the optimization of the t-SNE cost function is much</span>
<span id="cb5-517"><a href="#cb5-517" aria-hidden="true" tabindex="-1"></a>easier than the optimization of the cost functions of SNE and</span>
<span id="cb5-518"><a href="#cb5-518" aria-hidden="true" tabindex="-1"></a>UNI-SNE. Specifically, t-SNE introduces long-range forces in the</span>
<span id="cb5-519"><a href="#cb5-519" aria-hidden="true" tabindex="-1"></a>low-dimensional map that can pull back together two (clusters of)</span>
<span id="cb5-520"><a href="#cb5-520" aria-hidden="true" tabindex="-1"></a>similar points that get separated early on in the optimization. SNE</span>
<span id="cb5-521"><a href="#cb5-521" aria-hidden="true" tabindex="-1"></a>and UNI-SNE do not have such long-range forces, as a result of which</span>
<span id="cb5-522"><a href="#cb5-522" aria-hidden="true" tabindex="-1"></a>SNE and UNI-SNE need to use simulated annealing to obtain reasonable</span>
<span id="cb5-523"><a href="#cb5-523" aria-hidden="true" tabindex="-1"></a>solutions. Instead, the long-range forces in t-SNE facilitate the</span>
<span id="cb5-524"><a href="#cb5-524" aria-hidden="true" tabindex="-1"></a>identification of good local optima without resorting to simulated</span>
<span id="cb5-525"><a href="#cb5-525" aria-hidden="true" tabindex="-1"></a>annealing</span>
<span id="cb5-526"><a href="#cb5-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-527"><a href="#cb5-527" aria-hidden="true" tabindex="-1"></a><span class="in">```{.pseudocode}</span></span>
<span id="cb5-528"><a href="#cb5-528" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb5-529"><a href="#cb5-529" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Simple version of t-Distributed Stochastic Neighbor Embeding}</span></span>
<span id="cb5-530"><a href="#cb5-530" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb5-531"><a href="#cb5-531" aria-hidden="true" tabindex="-1"></a><span class="in">\State \textbf{Data}: high-dimensional representation $\mathcal{X} = \{x_1, \dots, x_n\}$</span></span>
<span id="cb5-532"><a href="#cb5-532" aria-hidden="true" tabindex="-1"></a><span class="in">\State cost function parameters: perplexity  $Perp$</span></span>
<span id="cb5-533"><a href="#cb5-533" aria-hidden="true" tabindex="-1"></a><span class="in">\State optimization parameters: number of iterations $T$, learning rate $\eta$, momentum $\alpha(t)$</span></span>
<span id="cb5-534"><a href="#cb5-534" aria-hidden="true" tabindex="-1"></a><span class="in">\State \textbf{Result}: low-dimensional data representation $\mathcal{Y}^{(T)} = \{y_1, \dots, y_n\}$</span></span>
<span id="cb5-535"><a href="#cb5-535" aria-hidden="true" tabindex="-1"></a><span class="in">\Procedure{t-sne}{$Perp, T, \eta, \alpha(t)$}</span></span>
<span id="cb5-536"><a href="#cb5-536" aria-hidden="true" tabindex="-1"></a><span class="in">    \State compute pairwise affinities $p_{j|i}$ with perplexity $Perp$ (using Equation 1)</span></span>
<span id="cb5-537"><a href="#cb5-537" aria-hidden="true" tabindex="-1"></a><span class="in">    \State set $p_{ij} = \frac{1}{2n} (p_{j|i} + p_{i|j})$</span></span>
<span id="cb5-538"><a href="#cb5-538" aria-hidden="true" tabindex="-1"></a><span class="in">    \State sample initial solution $\mathcal{Y}^{(0)} = \{y_1,\dots,y_n\}$ from $\mathcal{N}(0,1e^{-4} I)$</span></span>
<span id="cb5-539"><a href="#cb5-539" aria-hidden="true" tabindex="-1"></a><span class="in">    \For{$t = 0$\dots$T$}</span></span>
<span id="cb5-540"><a href="#cb5-540" aria-hidden="true" tabindex="-1"></a><span class="in">        \State compute low-dimensional affinities $q_{ij}$ (using Equation 4)</span></span>
<span id="cb5-541"><a href="#cb5-541" aria-hidden="true" tabindex="-1"></a><span class="in">        \State compute gradient $\frac{\partial C}{\partial \mathcal{Y}}$ (using Equation 5)</span></span>
<span id="cb5-542"><a href="#cb5-542" aria-hidden="true" tabindex="-1"></a><span class="in">        \State et $\mathcal{Y}^{t} = \mathcal{Y}^{t-1} + \eta \frac{\partial C}{\partial \mathcal{Y}} + \alpha(t) \left(\mathcal{Y}^{t-1} - \mathcal{Y}^{t-2}\right)$ </span></span>
<span id="cb5-543"><a href="#cb5-543" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndFor</span></span>
<span id="cb5-544"><a href="#cb5-544" aria-hidden="true" tabindex="-1"></a><span class="in">\EndProcedure</span></span>
<span id="cb5-545"><a href="#cb5-545" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb5-546"><a href="#cb5-546" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb5-547"><a href="#cb5-547" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-548"><a href="#cb5-548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-549"><a href="#cb5-549" aria-hidden="true" tabindex="-1"></a><span class="fu">## Optimization methods for t-SNE {#sec-optimization_methods_for_tsne}</span></span>
<span id="cb5-550"><a href="#cb5-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-551"><a href="#cb5-551" aria-hidden="true" tabindex="-1"></a>We start by presenting a relatively simple, gradient descent procedure for</span>
<span id="cb5-552"><a href="#cb5-552" aria-hidden="true" tabindex="-1"></a>optimizing the t-SNE cost function. This simple procedure uses a momentum term</span>
<span id="cb5-553"><a href="#cb5-553" aria-hidden="true" tabindex="-1"></a>to reduce the number of iterations required and it works best if the momentum</span>
<span id="cb5-554"><a href="#cb5-554" aria-hidden="true" tabindex="-1"></a>term is small until the map points have become moderately well organized.</span>
<span id="cb5-555"><a href="#cb5-555" aria-hidden="true" tabindex="-1"></a>Pseudocode for this simple algorithm is presented in Algorithm 1 (FIXME: ref not working). The</span>
<span id="cb5-556"><a href="#cb5-556" aria-hidden="true" tabindex="-1"></a>simple algorithm can be sped up using the adaptive learning rate scheme that</span>
<span id="cb5-557"><a href="#cb5-557" aria-hidden="true" tabindex="-1"></a>is described by @jacobs:rates, which gradually increases the learning</span>
<span id="cb5-558"><a href="#cb5-558" aria-hidden="true" tabindex="-1"></a>rate in directions in which the gradient is stable.</span>
<span id="cb5-559"><a href="#cb5-559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-560"><a href="#cb5-560" aria-hidden="true" tabindex="-1"></a>Although the simple algorithm produces visualizations that are often much</span>
<span id="cb5-561"><a href="#cb5-561" aria-hidden="true" tabindex="-1"></a>better than those produced by other non-parametric dimensionality reduction</span>
<span id="cb5-562"><a href="#cb5-562" aria-hidden="true" tabindex="-1"></a>techniques, the results can be improved further by using either of two tricks.</span>
<span id="cb5-563"><a href="#cb5-563" aria-hidden="true" tabindex="-1"></a>The first trick, which we call "early compression," is to force the map points</span>
<span id="cb5-564"><a href="#cb5-564" aria-hidden="true" tabindex="-1"></a>to stay close together at the start of the optimization. When the distances</span>
<span id="cb5-565"><a href="#cb5-565" aria-hidden="true" tabindex="-1"></a>between map points are small, it is easy for clusters to move through one</span>
<span id="cb5-566"><a href="#cb5-566" aria-hidden="true" tabindex="-1"></a>another so it is much easier to explore the space of possible global</span>
<span id="cb5-567"><a href="#cb5-567" aria-hidden="true" tabindex="-1"></a>organizations of the data. Early compression is implemented by adding an</span>
<span id="cb5-568"><a href="#cb5-568" aria-hidden="true" tabindex="-1"></a>additional L2-penalty to the cost function that is proportional to the sum of</span>
<span id="cb5-569"><a href="#cb5-569" aria-hidden="true" tabindex="-1"></a>squared distances of the map points from the origin. The magnitude of this</span>
<span id="cb5-570"><a href="#cb5-570" aria-hidden="true" tabindex="-1"></a>penalty term and the iteration at which it is removed are set by hand, but the</span>
<span id="cb5-571"><a href="#cb5-571" aria-hidden="true" tabindex="-1"></a>behavior is fairly robust across variations in these two additional</span>
<span id="cb5-572"><a href="#cb5-572" aria-hidden="true" tabindex="-1"></a>optimization parameters.</span>
<span id="cb5-573"><a href="#cb5-573" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-574"><a href="#cb5-574" aria-hidden="true" tabindex="-1"></a>A less obvious way to improve the optimization, which we call "early</span>
<span id="cb5-575"><a href="#cb5-575" aria-hidden="true" tabindex="-1"></a>exaggeration," is to multiply all of the $p_{ij}$'s by, for example, 4, in the</span>
<span id="cb5-576"><a href="#cb5-576" aria-hidden="true" tabindex="-1"></a>initial stages of the optimization. This means that almost all of the</span>
<span id="cb5-577"><a href="#cb5-577" aria-hidden="true" tabindex="-1"></a>$q_{ij}$'s, which still add up to 1, are much too small to model their</span>
<span id="cb5-578"><a href="#cb5-578" aria-hidden="true" tabindex="-1"></a>corresponding $p_{ij}$'s. As a result, the optimization is encouraged to focus</span>
<span id="cb5-579"><a href="#cb5-579" aria-hidden="true" tabindex="-1"></a>on modeling the large $p_{ij}$'s by fairly large $q {ij}$'s. The effect is</span>
<span id="cb5-580"><a href="#cb5-580" aria-hidden="true" tabindex="-1"></a>that the natural clusters in the data tend to form tight widely separated</span>
<span id="cb5-581"><a href="#cb5-581" aria-hidden="true" tabindex="-1"></a>clusters in the map. This creates a lot of relatively empty space in the map,</span>
<span id="cb5-582"><a href="#cb5-582" aria-hidden="true" tabindex="-1"></a>which makes it much easier for the clusters to move around relative to one</span>
<span id="cb5-583"><a href="#cb5-583" aria-hidden="true" tabindex="-1"></a>another in order to find a good global organization.</span>
<span id="cb5-584"><a href="#cb5-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-585"><a href="#cb5-585" aria-hidden="true" tabindex="-1"></a>In all the visualizations presented in this paper and in the</span>
<span id="cb5-586"><a href="#cb5-586" aria-hidden="true" tabindex="-1"></a>supporting material, we used exactly the same optimization</span>
<span id="cb5-587"><a href="#cb5-587" aria-hidden="true" tabindex="-1"></a>procedure. We used the early exaggeration method with an exaggeration</span>
<span id="cb5-588"><a href="#cb5-588" aria-hidden="true" tabindex="-1"></a>of 4 for the first 50 iterations (note that early exaggeration is not</span>
<span id="cb5-589"><a href="#cb5-589" aria-hidden="true" tabindex="-1"></a>included in the pseudocode in Algorithm 1). The number of</span>
<span id="cb5-590"><a href="#cb5-590" aria-hidden="true" tabindex="-1"></a>gradient descent iterations $T$ was set 1000, and the momentum term</span>
<span id="cb5-591"><a href="#cb5-591" aria-hidden="true" tabindex="-1"></a>was set to $\alpha^{(t)} = 0.5$ for $t&lt;250$ and $\alpha^{(t)}=0.8$ for</span>
<span id="cb5-592"><a href="#cb5-592" aria-hidden="true" tabindex="-1"></a>$t \geq 250$. The learning rate $\eta$ is initially set to 100 and it</span>
<span id="cb5-593"><a href="#cb5-593" aria-hidden="true" tabindex="-1"></a>is updated after every iteration by means of the adaptive learning</span>
<span id="cb5-594"><a href="#cb5-594" aria-hidden="true" tabindex="-1"></a>rate scheme described by @jacobs:rates. A Matlab implementation of the</span>
<span id="cb5-595"><a href="#cb5-595" aria-hidden="true" tabindex="-1"></a>resulting algorithm is available at</span>
<span id="cb5-596"><a href="#cb5-596" aria-hidden="true" tabindex="-1"></a><span class="ot">&lt;https://lvdmaaten.github.io/tsne/&gt;</span>.</span>
<span id="cb5-597"><a href="#cb5-597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-598"><a href="#cb5-598" aria-hidden="true" tabindex="-1"></a><span class="fu"># Experiments {#sec-experiments}</span></span>
<span id="cb5-599"><a href="#cb5-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-600"><a href="#cb5-600" aria-hidden="true" tabindex="-1"></a>To evaluate t-SNE, we present experiments in which t-SNE is compared to seven</span>
<span id="cb5-601"><a href="#cb5-601" aria-hidden="true" tabindex="-1"></a>other non-parametric techniques for dimensionality reduction. Because of space</span>
<span id="cb5-602"><a href="#cb5-602" aria-hidden="true" tabindex="-1"></a>limitations, in the paper, we only compare t-SNE with: (1) Sammon mapping, (2)</span>
<span id="cb5-603"><a href="#cb5-603" aria-hidden="true" tabindex="-1"></a>Isomap, and (3) LLE. In the supporting material, we also compare t-SNE with:</span>
<span id="cb5-604"><a href="#cb5-604" aria-hidden="true" tabindex="-1"></a>(4) CCA, (5) SNE, (6) MVU, and (7) Laplacian Eigenmaps. We performed</span>
<span id="cb5-605"><a href="#cb5-605" aria-hidden="true" tabindex="-1"></a>experiments on five data sets that represent a variety of application domains.</span>
<span id="cb5-606"><a href="#cb5-606" aria-hidden="true" tabindex="-1"></a>Again, because of space limitations, we restrict ourselves to three data sets</span>
<span id="cb5-607"><a href="#cb5-607" aria-hidden="true" tabindex="-1"></a>in the paper. The results of our experiments on the remaining two data sets</span>
<span id="cb5-608"><a href="#cb5-608" aria-hidden="true" tabindex="-1"></a>are presented in the supplementary material.</span>
<span id="cb5-609"><a href="#cb5-609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-610"><a href="#cb5-610" aria-hidden="true" tabindex="-1"></a>In @sec-datasets, the data sets that we employed in our</span>
<span id="cb5-611"><a href="#cb5-611" aria-hidden="true" tabindex="-1"></a>experiments are introduced. The setup of the experiments is presented in</span>
<span id="cb5-612"><a href="#cb5-612" aria-hidden="true" tabindex="-1"></a>@sec-experimental_setup. In @sec-results, we</span>
<span id="cb5-613"><a href="#cb5-613" aria-hidden="true" tabindex="-1"></a>present the results of our experiments.</span>
<span id="cb5-614"><a href="#cb5-614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-615"><a href="#cb5-615" aria-hidden="true" tabindex="-1"></a><span class="fu">## Data Sets {#sec-datasets}</span></span>
<span id="cb5-616"><a href="#cb5-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-617"><a href="#cb5-617" aria-hidden="true" tabindex="-1"></a>The five data sets we employed in our experiments are: (1) the MNIST data set,</span>
<span id="cb5-618"><a href="#cb5-618" aria-hidden="true" tabindex="-1"></a>(2) the Olivetti faces data set, (3) the COIL-20 data set, (4) the</span>
<span id="cb5-619"><a href="#cb5-619" aria-hidden="true" tabindex="-1"></a>word-features data set, and (5) the Netflix data set. We only present results</span>
<span id="cb5-620"><a href="#cb5-620" aria-hidden="true" tabindex="-1"></a>on the first three data sets in this section. The results on the remaining two</span>
<span id="cb5-621"><a href="#cb5-621" aria-hidden="true" tabindex="-1"></a>data sets are presented in the supporting material. The first three data sets</span>
<span id="cb5-622"><a href="#cb5-622" aria-hidden="true" tabindex="-1"></a>are introduced below.</span>
<span id="cb5-623"><a href="#cb5-623" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-624"><a href="#cb5-624" aria-hidden="true" tabindex="-1"></a>The MNIST data set<span class="ot">[^MNIST]</span> contains 60,000 grayscale images of</span>
<span id="cb5-625"><a href="#cb5-625" aria-hidden="true" tabindex="-1"></a>handwritten digits. For our experiments, we randomly selected 6,000 of</span>
<span id="cb5-626"><a href="#cb5-626" aria-hidden="true" tabindex="-1"></a>the images for computational reasons. The digit images have $28 \times</span>
<span id="cb5-627"><a href="#cb5-627" aria-hidden="true" tabindex="-1"></a>28 = 784$ pixels (i.e., dimensions). The Olivetti faces data</span>
<span id="cb5-628"><a href="#cb5-628" aria-hidden="true" tabindex="-1"></a>set<span class="ot">[^Olivetti]</span> consists of images of 40 individuals with small</span>
<span id="cb5-629"><a href="#cb5-629" aria-hidden="true" tabindex="-1"></a>variations in viewpoint, large variations in expression, and</span>
<span id="cb5-630"><a href="#cb5-630" aria-hidden="true" tabindex="-1"></a>occasional addition of glasses. The data set consists of 400 images</span>
<span id="cb5-631"><a href="#cb5-631" aria-hidden="true" tabindex="-1"></a>(10 per individual) of size $92\times 112=10,304$ pixels, and is</span>
<span id="cb5-632"><a href="#cb5-632" aria-hidden="true" tabindex="-1"></a>labeled according to identity. The COIL-20 data set</span>
<span id="cb5-633"><a href="#cb5-633" aria-hidden="true" tabindex="-1"></a>@nene:coil20 contains images of 20 different objects viewed</span>
<span id="cb5-634"><a href="#cb5-634" aria-hidden="true" tabindex="-1"></a>from 72 equally spaced orientations, yielding a total of 1,440</span>
<span id="cb5-635"><a href="#cb5-635" aria-hidden="true" tabindex="-1"></a>images. The images contain $32 \times 32 = 1,024$ pixels.</span>
<span id="cb5-636"><a href="#cb5-636" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-637"><a href="#cb5-637" aria-hidden="true" tabindex="-1"></a><span class="ot">[^MNIST]: </span>The MNIST data set is publicly available from <span class="ot">&lt;http://yann.lecun.com/exdb/mnist/index.html&gt;</span>.</span>
<span id="cb5-638"><a href="#cb5-638" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-639"><a href="#cb5-639" aria-hidden="true" tabindex="-1"></a><span class="ot">[^Olivetti]: </span>The Olivetti data set is publicly available from <span class="ot">&lt;http://mambo.ucsc.edu/psl/olivetti.html&gt;</span>.</span>
<span id="cb5-640"><a href="#cb5-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-641"><a href="#cb5-641" aria-hidden="true" tabindex="-1"></a><span class="fu">## Experimental Setup {#sec-experimental_setup}</span></span>
<span id="cb5-642"><a href="#cb5-642" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-643"><a href="#cb5-643" aria-hidden="true" tabindex="-1"></a>In all of our experiments, we start by using PCA to reduce the dimensionality</span>
<span id="cb5-644"><a href="#cb5-644" aria-hidden="true" tabindex="-1"></a>of the data to 30. This speeds up the computation of pairwise distances</span>
<span id="cb5-645"><a href="#cb5-645" aria-hidden="true" tabindex="-1"></a>between the datapoints and suppresses some noise without severely distorting</span>
<span id="cb5-646"><a href="#cb5-646" aria-hidden="true" tabindex="-1"></a>the interpoint distances. We then use each of the dimensionality reduction</span>
<span id="cb5-647"><a href="#cb5-647" aria-hidden="true" tabindex="-1"></a>techniques to convert the 30-dimensional representation to a two-dimensional</span>
<span id="cb5-648"><a href="#cb5-648" aria-hidden="true" tabindex="-1"></a>map and we show the resulting map as a scatterplot. For all of the data sets,</span>
<span id="cb5-649"><a href="#cb5-649" aria-hidden="true" tabindex="-1"></a>there is information about the class of each datapoint, but the class</span>
<span id="cb5-650"><a href="#cb5-650" aria-hidden="true" tabindex="-1"></a>information is only used to select a color and/or symbol for the map points.</span>
<span id="cb5-651"><a href="#cb5-651" aria-hidden="true" tabindex="-1"></a>The class information is not used to determine the spatial coordinates of the</span>
<span id="cb5-652"><a href="#cb5-652" aria-hidden="true" tabindex="-1"></a>map points. The coloring thus provides a way of evaluating how well the map</span>
<span id="cb5-653"><a href="#cb5-653" aria-hidden="true" tabindex="-1"></a>preserves the similarities within each class.</span>
<span id="cb5-654"><a href="#cb5-654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-655"><a href="#cb5-655" aria-hidden="true" tabindex="-1"></a>The cost function parameter settings we employed in our experiments are listed</span>
<span id="cb5-656"><a href="#cb5-656" aria-hidden="true" tabindex="-1"></a>in @tbl-cost-function-parameters. In the table, $Perp$ represents the</span>
<span id="cb5-657"><a href="#cb5-657" aria-hidden="true" tabindex="-1"></a>perplexity of the conditional probability distribution induced by a Gaussian</span>
<span id="cb5-658"><a href="#cb5-658" aria-hidden="true" tabindex="-1"></a>kernel and $k$ represents the number of nearest neighbors employed in a</span>
<span id="cb5-659"><a href="#cb5-659" aria-hidden="true" tabindex="-1"></a>neighborhood graph. In the experiments with Isomap and LLE, we only visualize</span>
<span id="cb5-660"><a href="#cb5-660" aria-hidden="true" tabindex="-1"></a>datapoints that correspond to vertices in the largest connected component of</span>
<span id="cb5-661"><a href="#cb5-661" aria-hidden="true" tabindex="-1"></a>the neighborhood graph. <span class="ot">[^neighborhood_graph]</span> For the Sammon mapping</span>
<span id="cb5-662"><a href="#cb5-662" aria-hidden="true" tabindex="-1"></a>optimization, we performed Newton's method for 500 iterations.</span>
<span id="cb5-663"><a href="#cb5-663" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-664"><a href="#cb5-664" aria-hidden="true" tabindex="-1"></a><span class="ot">[^neighborhood_graph]: </span>Isomap and LLE require data that gives rise to a</span>
<span id="cb5-665"><a href="#cb5-665" aria-hidden="true" tabindex="-1"></a>  neighborhood graph that is connected.</span>
<span id="cb5-666"><a href="#cb5-666" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-667"><a href="#cb5-667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-668"><a href="#cb5-668" aria-hidden="true" tabindex="-1"></a>| Technique      | Cost function parameters |</span>
<span id="cb5-669"><a href="#cb5-669" aria-hidden="true" tabindex="-1"></a>|----------------|-------------------------:|</span>
<span id="cb5-670"><a href="#cb5-670" aria-hidden="true" tabindex="-1"></a>| t-SNE          | $Perp = 40$              |</span>
<span id="cb5-671"><a href="#cb5-671" aria-hidden="true" tabindex="-1"></a>| Sammon mapping | none                     |</span>
<span id="cb5-672"><a href="#cb5-672" aria-hidden="true" tabindex="-1"></a>| Isomap         | $k=12$                   |</span>
<span id="cb5-673"><a href="#cb5-673" aria-hidden="true" tabindex="-1"></a>| LLE            | $k=12$                   |</span>
<span id="cb5-674"><a href="#cb5-674" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-675"><a href="#cb5-675" aria-hidden="true" tabindex="-1"></a>: Cost function parameter settings for the experiments {#tbl-cost-function-parameters}</span>
<span id="cb5-676"><a href="#cb5-676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-677"><a href="#cb5-677" aria-hidden="true" tabindex="-1"></a><span class="fu">## Results {#sec-results}</span></span>
<span id="cb5-678"><a href="#cb5-678" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-681"><a href="#cb5-681" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-682"><a href="#cb5-682" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-tsne-sammon</span></span>
<span id="cb5-683"><a href="#cb5-683" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Visualization by t-SNE and Sammon mapping"</span></span>
<span id="cb5-684"><a href="#cb5-684" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-685"><a href="#cb5-685" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb5-686"><a href="#cb5-686" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure 2. Visualization by t-SNE and Sammon mapping</span></span>
<span id="cb5-687"><a href="#cb5-687" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb5-688"><a href="#cb5-688" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-689"><a href="#cb5-689" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_digits</span>
<span id="cb5-690"><a href="#cb5-690" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-691"><a href="#cb5-691" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn <span class="im">import</span> manifold</span>
<span id="cb5-692"><a href="#cb5-692" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> joblib</span>
<span id="cb5-693"><a href="#cb5-693" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-694"><a href="#cb5-694" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb5-695"><a href="#cb5-695" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-696"><a href="#cb5-696" aria-hidden="true" tabindex="-1"></a>mem <span class="op">=</span> joblib.Memory(<span class="st">".joblib"</span>, verbose <span class="op">=</span> <span class="dv">0</span>)</span>
<span id="cb5-697"><a href="#cb5-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-698"><a href="#cb5-698" aria-hidden="true" tabindex="-1"></a>digits <span class="op">=</span> load_digits()</span>
<span id="cb5-699"><a href="#cb5-699" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-700"><a href="#cb5-700" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> digits[<span class="st">"data"</span>]</span>
<span id="cb5-701"><a href="#cb5-701" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> digits[<span class="st">"target"</span>]</span>
<span id="cb5-702"><a href="#cb5-702" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-703"><a href="#cb5-703" aria-hidden="true" tabindex="-1"></a>n_components <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb5-704"><a href="#cb5-704" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-705"><a href="#cb5-705" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-706"><a href="#cb5-706" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> {</span>
<span id="cb5-707"><a href="#cb5-707" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: <span class="st">"C0"</span>,</span>
<span id="cb5-708"><a href="#cb5-708" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: <span class="st">"C1"</span>,</span>
<span id="cb5-709"><a href="#cb5-709" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: <span class="st">"C2"</span>,</span>
<span id="cb5-710"><a href="#cb5-710" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: <span class="st">"C3"</span>,</span>
<span id="cb5-711"><a href="#cb5-711" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: <span class="st">"C4"</span>,</span>
<span id="cb5-712"><a href="#cb5-712" aria-hidden="true" tabindex="-1"></a>    <span class="dv">5</span>: <span class="st">"C5"</span>,</span>
<span id="cb5-713"><a href="#cb5-713" aria-hidden="true" tabindex="-1"></a>    <span class="dv">6</span>: <span class="st">"C6"</span>,</span>
<span id="cb5-714"><a href="#cb5-714" aria-hidden="true" tabindex="-1"></a>    <span class="dv">7</span>: <span class="st">"C7"</span>,</span>
<span id="cb5-715"><a href="#cb5-715" aria-hidden="true" tabindex="-1"></a>    <span class="dv">8</span>: <span class="st">"C8"</span>,</span>
<span id="cb5-716"><a href="#cb5-716" aria-hidden="true" tabindex="-1"></a>    <span class="dv">9</span>: <span class="st">"C9"</span>,</span>
<span id="cb5-717"><a href="#cb5-717" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-718"><a href="#cb5-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-719"><a href="#cb5-719" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(nrows<span class="op">=</span><span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">12</span>))</span>
<span id="cb5-720"><a href="#cb5-720" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-721"><a href="#cb5-721" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb5-722"><a href="#cb5-722" aria-hidden="true" tabindex="-1"></a><span class="co"># t-SNE manifold learning</span></span>
<span id="cb5-723"><a href="#cb5-723" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">0</span>]</span>
<span id="cb5-724"><a href="#cb5-724" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-725"><a href="#cb5-725" aria-hidden="true" tabindex="-1"></a>tsne <span class="op">=</span> manifold.TSNE(n_components<span class="op">=</span>n_components, init<span class="op">=</span><span class="st">"pca"</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb5-726"><a href="#cb5-726" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(tsne.fit_transform)(X)</span>
<span id="cb5-727"><a href="#cb5-727" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label <span class="kw">in</span> np.unique(y):</span>
<span id="cb5-728"><a href="#cb5-728" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb5-729"><a href="#cb5-729" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb5-730"><a href="#cb5-730" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb5-731"><a href="#cb5-731" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb5-732"><a href="#cb5-732" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span>colors[label], marker<span class="op">=</span><span class="st">"."</span>,</span>
<span id="cb5-733"><a href="#cb5-733" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb5-734"><a href="#cb5-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-735"><a href="#cb5-735" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-736"><a href="#cb5-736" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-737"><a href="#cb5-737" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-738"><a href="#cb5-738" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-739"><a href="#cb5-739" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb5-740"><a href="#cb5-740" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb5-741"><a href="#cb5-741" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"t-SNE"</span>)</span>
<span id="cb5-742"><a href="#cb5-742" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-743"><a href="#cb5-743" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb5-744"><a href="#cb5-744" aria-hidden="true" tabindex="-1"></a><span class="co"># Sammon mapping</span></span>
<span id="cb5-745"><a href="#cb5-745" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-746"><a href="#cb5-746" aria-hidden="true" tabindex="-1"></a><span class="co"># </span><span class="al">FIXME</span><span class="co"> I think Sammon mapping has weights?</span></span>
<span id="cb5-747"><a href="#cb5-747" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">1</span>]</span>
<span id="cb5-748"><a href="#cb5-748" aria-hidden="true" tabindex="-1"></a>embedding <span class="op">=</span> manifold.MDS(n_components<span class="op">=</span>n_components)</span>
<span id="cb5-749"><a href="#cb5-749" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(embedding.fit_transform)(X)</span>
<span id="cb5-750"><a href="#cb5-750" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label <span class="kw">in</span> np.unique(y):</span>
<span id="cb5-751"><a href="#cb5-751" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb5-752"><a href="#cb5-752" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb5-753"><a href="#cb5-753" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb5-754"><a href="#cb5-754" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb5-755"><a href="#cb5-755" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span>colors[label], marker<span class="op">=</span><span class="st">"."</span>,</span>
<span id="cb5-756"><a href="#cb5-756" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb5-757"><a href="#cb5-757" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-758"><a href="#cb5-758" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-759"><a href="#cb5-759" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-760"><a href="#cb5-760" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-761"><a href="#cb5-761" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-762"><a href="#cb5-762" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb5-763"><a href="#cb5-763" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb5-764"><a href="#cb5-764" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Sammon mapping"</span>)</span>
<span id="cb5-765"><a href="#cb5-765" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb5-766"><a href="#cb5-766" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-767"><a href="#cb5-767" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-770"><a href="#cb5-770" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-771"><a href="#cb5-771" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-isomap-lle</span></span>
<span id="cb5-772"><a href="#cb5-772" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Visualization by Isomap and LLE"</span></span>
<span id="cb5-773"><a href="#cb5-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-774"><a href="#cb5-774" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb5-775"><a href="#cb5-775" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure 3. Visualization by Isomap and LLE</span></span>
<span id="cb5-776"><a href="#cb5-776" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb5-777"><a href="#cb5-777" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-778"><a href="#cb5-778" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(nrows<span class="op">=</span><span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">12</span>))</span>
<span id="cb5-779"><a href="#cb5-779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-780"><a href="#cb5-780" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb5-781"><a href="#cb5-781" aria-hidden="true" tabindex="-1"></a><span class="co"># ISOMAP</span></span>
<span id="cb5-782"><a href="#cb5-782" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">0</span>]</span>
<span id="cb5-783"><a href="#cb5-783" aria-hidden="true" tabindex="-1"></a>isomap <span class="op">=</span> manifold.Isomap(n_components<span class="op">=</span>n_components, n_neighbors<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb5-784"><a href="#cb5-784" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(isomap.fit_transform)(X)</span>
<span id="cb5-785"><a href="#cb5-785" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label <span class="kw">in</span> np.unique(y):</span>
<span id="cb5-786"><a href="#cb5-786" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb5-787"><a href="#cb5-787" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb5-788"><a href="#cb5-788" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb5-789"><a href="#cb5-789" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb5-790"><a href="#cb5-790" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span>colors[label], marker<span class="op">=</span><span class="st">"."</span>,</span>
<span id="cb5-791"><a href="#cb5-791" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb5-792"><a href="#cb5-792" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-793"><a href="#cb5-793" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-794"><a href="#cb5-794" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-795"><a href="#cb5-795" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-796"><a href="#cb5-796" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-797"><a href="#cb5-797" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb5-798"><a href="#cb5-798" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb5-799"><a href="#cb5-799" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Isomap"</span>)</span>
<span id="cb5-800"><a href="#cb5-800" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-801"><a href="#cb5-801" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb5-802"><a href="#cb5-802" aria-hidden="true" tabindex="-1"></a><span class="co"># LLE</span></span>
<span id="cb5-803"><a href="#cb5-803" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">1</span>]</span>
<span id="cb5-804"><a href="#cb5-804" aria-hidden="true" tabindex="-1"></a>embedding <span class="op">=</span> manifold.LocallyLinearEmbedding(</span>
<span id="cb5-805"><a href="#cb5-805" aria-hidden="true" tabindex="-1"></a>    n_components<span class="op">=</span>n_components,</span>
<span id="cb5-806"><a href="#cb5-806" aria-hidden="true" tabindex="-1"></a>    n_neighbors<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb5-807"><a href="#cb5-807" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(embedding.fit_transform)(X)</span>
<span id="cb5-808"><a href="#cb5-808" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label <span class="kw">in</span> np.unique(y):</span>
<span id="cb5-809"><a href="#cb5-809" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb5-810"><a href="#cb5-810" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb5-811"><a href="#cb5-811" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb5-812"><a href="#cb5-812" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb5-813"><a href="#cb5-813" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span>colors[label], marker<span class="op">=</span><span class="st">"."</span>,</span>
<span id="cb5-814"><a href="#cb5-814" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb5-815"><a href="#cb5-815" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-816"><a href="#cb5-816" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-817"><a href="#cb5-817" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-818"><a href="#cb5-818" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-819"><a href="#cb5-819" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-820"><a href="#cb5-820" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb5-821"><a href="#cb5-821" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb5-822"><a href="#cb5-822" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"LLE"</span>)</span>
<span id="cb5-823"><a href="#cb5-823" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb5-824"><a href="#cb5-824" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-825"><a href="#cb5-825" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-828"><a href="#cb5-828" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-829"><a href="#cb5-829" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-olivetti</span></span>
<span id="cb5-830"><a href="#cb5-830" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Visualization of the Olivetti faces data set"</span></span>
<span id="cb5-831"><a href="#cb5-831" aria-hidden="true" tabindex="-1"></a><span class="co">#| error: false</span></span>
<span id="cb5-832"><a href="#cb5-832" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-833"><a href="#cb5-833" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb5-834"><a href="#cb5-834" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure 4. Visualization of the Olivetti faces data set</span></span>
<span id="cb5-835"><a href="#cb5-835" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb5-836"><a href="#cb5-836" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-837"><a href="#cb5-837" aria-hidden="true" tabindex="-1"></a><span class="co"># First, load the olivetti datasets</span></span>
<span id="cb5-838"><a href="#cb5-838" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> fetch_olivetti_faces</span>
<span id="cb5-839"><a href="#cb5-839" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb5-840"><a href="#cb5-840" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-841"><a href="#cb5-841" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> fetch_olivetti_faces()</span>
<span id="cb5-842"><a href="#cb5-842" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> data[<span class="st">"data"</span>]</span>
<span id="cb5-843"><a href="#cb5-843" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> data[<span class="st">"target"</span>]</span>
<span id="cb5-844"><a href="#cb5-844" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-845"><a href="#cb5-845" aria-hidden="true" tabindex="-1"></a>markers <span class="op">=</span> [<span class="st">"+"</span>, <span class="st">"."</span>, <span class="st">"v"</span>, <span class="st">"^"</span>, <span class="st">"&gt;"</span>, <span class="st">"&lt;"</span>, <span class="st">"d"</span>, <span class="st">"*"</span>]</span>
<span id="cb5-846"><a href="#cb5-846" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">"black"</span>, <span class="st">"blue"</span>, <span class="st">"red"</span>, <span class="st">"pink"</span>]</span>
<span id="cb5-847"><a href="#cb5-847" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-848"><a href="#cb5-848" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(nrows<span class="op">=</span><span class="dv">2</span>, ncols<span class="op">=</span><span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">8</span>))</span>
<span id="cb5-849"><a href="#cb5-849" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-850"><a href="#cb5-850" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb5-851"><a href="#cb5-851" aria-hidden="true" tabindex="-1"></a><span class="co"># t-SNE manifold learning</span></span>
<span id="cb5-852"><a href="#cb5-852" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb5-853"><a href="#cb5-853" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-854"><a href="#cb5-854" aria-hidden="true" tabindex="-1"></a>tsne <span class="op">=</span> manifold.TSNE(n_components<span class="op">=</span>n_components, init<span class="op">=</span><span class="st">"pca"</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb5-855"><a href="#cb5-855" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(tsne.fit_transform)(X)</span>
<span id="cb5-856"><a href="#cb5-856" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label, (m, c) <span class="kw">in</span> <span class="bu">zip</span>(np.unique(y), itertools.product(markers, colors)):</span>
<span id="cb5-857"><a href="#cb5-857" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb5-858"><a href="#cb5-858" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb5-859"><a href="#cb5-859" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb5-860"><a href="#cb5-860" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb5-861"><a href="#cb5-861" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span>m, c<span class="op">=</span>c,</span>
<span id="cb5-862"><a href="#cb5-862" aria-hidden="true" tabindex="-1"></a>    s<span class="op">=</span><span class="dv">8</span>,</span>
<span id="cb5-863"><a href="#cb5-863" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb5-864"><a href="#cb5-864" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-865"><a href="#cb5-865" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-866"><a href="#cb5-866" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-867"><a href="#cb5-867" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-868"><a href="#cb5-868" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-869"><a href="#cb5-869" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb5-870"><a href="#cb5-870" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb5-871"><a href="#cb5-871" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"t-SNE"</span>)</span>
<span id="cb5-872"><a href="#cb5-872" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-873"><a href="#cb5-873" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb5-874"><a href="#cb5-874" aria-hidden="true" tabindex="-1"></a><span class="co"># Sammon mapping</span></span>
<span id="cb5-875"><a href="#cb5-875" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-876"><a href="#cb5-876" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb5-877"><a href="#cb5-877" aria-hidden="true" tabindex="-1"></a>embedding <span class="op">=</span> manifold.MDS(n_components<span class="op">=</span>n_components)</span>
<span id="cb5-878"><a href="#cb5-878" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(embedding.fit_transform)(X)</span>
<span id="cb5-879"><a href="#cb5-879" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label, (m, c) <span class="kw">in</span> <span class="bu">zip</span>(np.unique(y), itertools.product(markers, colors)):</span>
<span id="cb5-880"><a href="#cb5-880" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb5-881"><a href="#cb5-881" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb5-882"><a href="#cb5-882" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb5-883"><a href="#cb5-883" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb5-884"><a href="#cb5-884" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span>m, c<span class="op">=</span>c,</span>
<span id="cb5-885"><a href="#cb5-885" aria-hidden="true" tabindex="-1"></a>    s<span class="op">=</span><span class="dv">8</span>,</span>
<span id="cb5-886"><a href="#cb5-886" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb5-887"><a href="#cb5-887" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-888"><a href="#cb5-888" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-889"><a href="#cb5-889" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-890"><a href="#cb5-890" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-891"><a href="#cb5-891" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-892"><a href="#cb5-892" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb5-893"><a href="#cb5-893" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb5-894"><a href="#cb5-894" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Sammon mapping"</span>)</span>
<span id="cb5-895"><a href="#cb5-895" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-896"><a href="#cb5-896" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb5-897"><a href="#cb5-897" aria-hidden="true" tabindex="-1"></a><span class="co"># ISOMAP</span></span>
<span id="cb5-898"><a href="#cb5-898" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">1</span>, <span class="dv">0</span>]</span>
<span id="cb5-899"><a href="#cb5-899" aria-hidden="true" tabindex="-1"></a>isomap <span class="op">=</span> manifold.Isomap(n_components<span class="op">=</span>n_components, n_neighbors<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb5-900"><a href="#cb5-900" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(isomap.fit_transform)(X)</span>
<span id="cb5-901"><a href="#cb5-901" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label, (m, c) <span class="kw">in</span> <span class="bu">zip</span>(np.unique(y), itertools.product(markers, colors)):</span>
<span id="cb5-902"><a href="#cb5-902" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb5-903"><a href="#cb5-903" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb5-904"><a href="#cb5-904" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb5-905"><a href="#cb5-905" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb5-906"><a href="#cb5-906" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span>m, c<span class="op">=</span>c,</span>
<span id="cb5-907"><a href="#cb5-907" aria-hidden="true" tabindex="-1"></a>    s<span class="op">=</span><span class="dv">8</span>,</span>
<span id="cb5-908"><a href="#cb5-908" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb5-909"><a href="#cb5-909" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-910"><a href="#cb5-910" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-911"><a href="#cb5-911" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-912"><a href="#cb5-912" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-913"><a href="#cb5-913" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-914"><a href="#cb5-914" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb5-915"><a href="#cb5-915" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb5-916"><a href="#cb5-916" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Isomap"</span>)</span>
<span id="cb5-917"><a href="#cb5-917" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-918"><a href="#cb5-918" aria-hidden="true" tabindex="-1"></a><span class="co">###############################################################################</span></span>
<span id="cb5-919"><a href="#cb5-919" aria-hidden="true" tabindex="-1"></a><span class="co"># LLE</span></span>
<span id="cb5-920"><a href="#cb5-920" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> axes[<span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="cb5-921"><a href="#cb5-921" aria-hidden="true" tabindex="-1"></a>embedding <span class="op">=</span> manifold.LocallyLinearEmbedding(</span>
<span id="cb5-922"><a href="#cb5-922" aria-hidden="true" tabindex="-1"></a>    n_components<span class="op">=</span>n_components,</span>
<span id="cb5-923"><a href="#cb5-923" aria-hidden="true" tabindex="-1"></a>    n_neighbors<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb5-924"><a href="#cb5-924" aria-hidden="true" tabindex="-1"></a>X_transformed <span class="op">=</span> mem.cache(embedding.fit_transform)(X)</span>
<span id="cb5-925"><a href="#cb5-925" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-926"><a href="#cb5-926" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> label, (m, c) <span class="kw">in</span> <span class="bu">zip</span>(np.unique(y), itertools.product(markers, colors)):</span>
<span id="cb5-927"><a href="#cb5-927" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> label</span>
<span id="cb5-928"><a href="#cb5-928" aria-hidden="true" tabindex="-1"></a>    ax.scatter(</span>
<span id="cb5-929"><a href="#cb5-929" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">0</span>],</span>
<span id="cb5-930"><a href="#cb5-930" aria-hidden="true" tabindex="-1"></a>        X_transformed[mask, <span class="dv">1</span>],</span>
<span id="cb5-931"><a href="#cb5-931" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span>m, c<span class="op">=</span>c,</span>
<span id="cb5-932"><a href="#cb5-932" aria-hidden="true" tabindex="-1"></a>    s<span class="op">=</span><span class="dv">8</span>,</span>
<span id="cb5-933"><a href="#cb5-933" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span>label)</span>
<span id="cb5-934"><a href="#cb5-934" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-935"><a href="#cb5-935" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"left"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-936"><a href="#cb5-936" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-937"><a href="#cb5-937" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-938"><a href="#cb5-938" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"bottom"</span>].set_linewidth(<span class="dv">0</span>)</span>
<span id="cb5-939"><a href="#cb5-939" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb5-940"><a href="#cb5-940" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb5-941"><a href="#cb5-941" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"LLE"</span>)</span>
<span id="cb5-942"><a href="#cb5-942" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb5-943"><a href="#cb5-943" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-944"><a href="#cb5-944" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-945"><a href="#cb5-945" aria-hidden="true" tabindex="-1"></a>In @fig-tsne-sammon and @fig-isomap-lle, we show the results of our experiments with t-SNE,</span>
<span id="cb5-946"><a href="#cb5-946" aria-hidden="true" tabindex="-1"></a>Sammon mapping, Isomap, and LLE on the MNIST data set. The results</span>
<span id="cb5-947"><a href="#cb5-947" aria-hidden="true" tabindex="-1"></a>reveal the strong performance of t-SNE compared to the other</span>
<span id="cb5-948"><a href="#cb5-948" aria-hidden="true" tabindex="-1"></a>techniques. In particular, Sammon mapping constructs a "ball" in which</span>
<span id="cb5-949"><a href="#cb5-949" aria-hidden="true" tabindex="-1"></a>only three classes (representing the digits 0, 1, and 7) are somewhat</span>
<span id="cb5-950"><a href="#cb5-950" aria-hidden="true" tabindex="-1"></a>separated from the other classes. Isomap and LLE produce solutions in</span>
<span id="cb5-951"><a href="#cb5-951" aria-hidden="true" tabindex="-1"></a>which there are large overlaps between the digit classes. In contrast,</span>
<span id="cb5-952"><a href="#cb5-952" aria-hidden="true" tabindex="-1"></a>tSNE constructs a map in which the separation between the digit</span>
<span id="cb5-953"><a href="#cb5-953" aria-hidden="true" tabindex="-1"></a>classes is almost perfect. Moreover, detailed inspection of the t-SNE</span>
<span id="cb5-954"><a href="#cb5-954" aria-hidden="true" tabindex="-1"></a>map reveals that much of the local structure of the data (such as the</span>
<span id="cb5-955"><a href="#cb5-955" aria-hidden="true" tabindex="-1"></a>orientation of the ones) is captured as well. This is illustrated in</span>
<span id="cb5-956"><a href="#cb5-956" aria-hidden="true" tabindex="-1"></a>more detail in @sec-large-data (see @fig-random-walk-tsne). The map produced by t-SNE</span>
<span id="cb5-957"><a href="#cb5-957" aria-hidden="true" tabindex="-1"></a>contains some points that are clustered with the wrong class, but most</span>
<span id="cb5-958"><a href="#cb5-958" aria-hidden="true" tabindex="-1"></a>of these points correspond to distorted digits many of which are</span>
<span id="cb5-959"><a href="#cb5-959" aria-hidden="true" tabindex="-1"></a>difficult to identify. @fig-olivetti shows the results of applying t-SNE,</span>
<span id="cb5-960"><a href="#cb5-960" aria-hidden="true" tabindex="-1"></a>Sammon mapping, Isomap, and LLE to the Olivetti faces data set. Again,</span>
<span id="cb5-961"><a href="#cb5-961" aria-hidden="true" tabindex="-1"></a>Isomap and LLE produce solutions that provide little insight into the</span>
<span id="cb5-962"><a href="#cb5-962" aria-hidden="true" tabindex="-1"></a>class structure of the data. The map constructed by Sammon mapping is</span>
<span id="cb5-963"><a href="#cb5-963" aria-hidden="true" tabindex="-1"></a>significantly better, since it models many of the members of each</span>
<span id="cb5-964"><a href="#cb5-964" aria-hidden="true" tabindex="-1"></a>class fairly close together, but none of the classes are clearly</span>
<span id="cb5-965"><a href="#cb5-965" aria-hidden="true" tabindex="-1"></a>separated in the Sammon map. In contrast, t-SNE does a much better job</span>
<span id="cb5-966"><a href="#cb5-966" aria-hidden="true" tabindex="-1"></a>of revealing the natural classes in the data. Some individuals have</span>
<span id="cb5-967"><a href="#cb5-967" aria-hidden="true" tabindex="-1"></a>their ten images split into two clusters, usually because a subset of</span>
<span id="cb5-968"><a href="#cb5-968" aria-hidden="true" tabindex="-1"></a>the images have the head facing in a significantly different</span>
<span id="cb5-969"><a href="#cb5-969" aria-hidden="true" tabindex="-1"></a>direction, or because they have a very different expression or</span>
<span id="cb5-970"><a href="#cb5-970" aria-hidden="true" tabindex="-1"></a>glasses. For these individuals, it is not clear that their ten images</span>
<span id="cb5-971"><a href="#cb5-971" aria-hidden="true" tabindex="-1"></a>form a natural class when using Euclidean distance in pixel space.</span>
<span id="cb5-972"><a href="#cb5-972" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-973"><a href="#cb5-973" aria-hidden="true" tabindex="-1"></a>Figure 5 shows the results of applying t-SNE, Sammon mapping, Isomap,</span>
<span id="cb5-974"><a href="#cb5-974" aria-hidden="true" tabindex="-1"></a>and LLE to the COIL20 data set. For many of the 20 objects, t-SNE</span>
<span id="cb5-975"><a href="#cb5-975" aria-hidden="true" tabindex="-1"></a>accurately represents the one-dimensional manifold of viewpoints as a</span>
<span id="cb5-976"><a href="#cb5-976" aria-hidden="true" tabindex="-1"></a>closed loop. For objects which look similar from the front and the</span>
<span id="cb5-977"><a href="#cb5-977" aria-hidden="true" tabindex="-1"></a>back, t-SNE distorts the loop so that the images of front and back are</span>
<span id="cb5-978"><a href="#cb5-978" aria-hidden="true" tabindex="-1"></a>mapped to nearby points. For the four types of toy car in the COIL-20</span>
<span id="cb5-979"><a href="#cb5-979" aria-hidden="true" tabindex="-1"></a>data set (the four aligned "sausages" in the bottom-left of the tSNE</span>
<span id="cb5-980"><a href="#cb5-980" aria-hidden="true" tabindex="-1"></a>map), the four rotation manifolds are aligned by the orientation of</span>
<span id="cb5-981"><a href="#cb5-981" aria-hidden="true" tabindex="-1"></a>the cars to capture the high similarity between different cars at the</span>
<span id="cb5-982"><a href="#cb5-982" aria-hidden="true" tabindex="-1"></a>same orientation. This prevents t-SNE from keeping the four manifolds</span>
<span id="cb5-983"><a href="#cb5-983" aria-hidden="true" tabindex="-1"></a>clearly separate. Figure 5 also reveals that the other three</span>
<span id="cb5-984"><a href="#cb5-984" aria-hidden="true" tabindex="-1"></a>techniques are not nearly as good at cleanly separating the manifolds</span>
<span id="cb5-985"><a href="#cb5-985" aria-hidden="true" tabindex="-1"></a>that correspond to very different objects. In addition, Isomap and LLE</span>
<span id="cb5-986"><a href="#cb5-986" aria-hidden="true" tabindex="-1"></a>only visualize a small number of classes from the COIL-20 data set,</span>
<span id="cb5-987"><a href="#cb5-987" aria-hidden="true" tabindex="-1"></a>because the data set comprises a large number of widely separated</span>
<span id="cb5-988"><a href="#cb5-988" aria-hidden="true" tabindex="-1"></a>submanifolds that give rise to small connected components in the</span>
<span id="cb5-989"><a href="#cb5-989" aria-hidden="true" tabindex="-1"></a>neighborhood graph.</span>
<span id="cb5-990"><a href="#cb5-990" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-991"><a href="#cb5-991" aria-hidden="true" tabindex="-1"></a><span class="fu"># Applying t-SNE to Large Data Sets {#sec-large-data}</span></span>
<span id="cb5-992"><a href="#cb5-992" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-993"><a href="#cb5-993" aria-hidden="true" tabindex="-1"></a>Like many other visualization techniques, t-SNE has a computational</span>
<span id="cb5-994"><a href="#cb5-994" aria-hidden="true" tabindex="-1"></a>and memory complexity that is quadratic in the number of</span>
<span id="cb5-995"><a href="#cb5-995" aria-hidden="true" tabindex="-1"></a>datapoints. This makes it infeasible to apply the standard version of</span>
<span id="cb5-996"><a href="#cb5-996" aria-hidden="true" tabindex="-1"></a>t-SNE to data sets that contain many more than, say, 10,000</span>
<span id="cb5-997"><a href="#cb5-997" aria-hidden="true" tabindex="-1"></a>points. Obviously, it is possible to pick a random subset of the</span>
<span id="cb5-998"><a href="#cb5-998" aria-hidden="true" tabindex="-1"></a>datapoints and display them using t-SNE, but such an approach fails to</span>
<span id="cb5-999"><a href="#cb5-999" aria-hidden="true" tabindex="-1"></a>make use of the information that the undisplayed datapoints provide</span>
<span id="cb5-1000"><a href="#cb5-1000" aria-hidden="true" tabindex="-1"></a>about the underlying manifolds.  Suppose, for example, that A, B, and</span>
<span id="cb5-1001"><a href="#cb5-1001" aria-hidden="true" tabindex="-1"></a>C are all equidistant in the high-dimensional space. If there are many</span>
<span id="cb5-1002"><a href="#cb5-1002" aria-hidden="true" tabindex="-1"></a>undisplayed datapoints between A and B and none between A and C, it is</span>
<span id="cb5-1003"><a href="#cb5-1003" aria-hidden="true" tabindex="-1"></a>much more likely that A and B are part of the same cluster than A and</span>
<span id="cb5-1004"><a href="#cb5-1004" aria-hidden="true" tabindex="-1"></a>C. This is illustrated in @fig-random-walk. In this section, we</span>
<span id="cb5-1005"><a href="#cb5-1005" aria-hidden="true" tabindex="-1"></a>show how t-SNE can be modified to display a random subset of the</span>
<span id="cb5-1006"><a href="#cb5-1006" aria-hidden="true" tabindex="-1"></a>datapoints (so-called landmark points) in a way that uses information</span>
<span id="cb5-1007"><a href="#cb5-1007" aria-hidden="true" tabindex="-1"></a>from the entire (possibly very large) data set.</span>
<span id="cb5-1008"><a href="#cb5-1008" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1009"><a href="#cb5-1009" aria-hidden="true" tabindex="-1"></a>![An illustration of the advantage of the random walk version of t-SNE over a standard</span>
<span id="cb5-1010"><a href="#cb5-1010" aria-hidden="true" tabindex="-1"></a>landmark approach. The shaded points A, B, and C are three (almost) equidistant landmark points, whereas the non-shaded datapoints are non-landmark points. The arrows represent a directed neighborhood graph where $k = 3$. In a standard landmark approach, the pairwise affinity between A and B is approximately equal to the pairwise affinity between A and C. In the random walk version of t-SNE, the pairwise affinity between A and B is much larger than the pairwise affinity between A and C, and therefore, it reflects the structure of the data much better.](figures/random-walk.png){#fig-random-walk}</span>
<span id="cb5-1011"><a href="#cb5-1011" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1012"><a href="#cb5-1012" aria-hidden="true" tabindex="-1"></a>We start by choosing a desired number of neighbors and creating a</span>
<span id="cb5-1013"><a href="#cb5-1013" aria-hidden="true" tabindex="-1"></a>neighborhood graph for all of the datapoints. Although this is</span>
<span id="cb5-1014"><a href="#cb5-1014" aria-hidden="true" tabindex="-1"></a>computationally intensive, it is only done once. Then, for each of the</span>
<span id="cb5-1015"><a href="#cb5-1015" aria-hidden="true" tabindex="-1"></a>landmark points, we define a random walk starting at that landmark</span>
<span id="cb5-1016"><a href="#cb5-1016" aria-hidden="true" tabindex="-1"></a>point and terminating as soon as it lands on another landmark</span>
<span id="cb5-1017"><a href="#cb5-1017" aria-hidden="true" tabindex="-1"></a>point. During a random walk, the probability of choosing an edge</span>
<span id="cb5-1018"><a href="#cb5-1018" aria-hidden="true" tabindex="-1"></a>emanating from node xi to node x j is proportional to $e^{-\|x_i−x_j</span>
<span id="cb5-1019"><a href="#cb5-1019" aria-hidden="true" tabindex="-1"></a>\|^2}$ . We define $p_{j|i}$ to be the fraction of random walks</span>
<span id="cb5-1020"><a href="#cb5-1020" aria-hidden="true" tabindex="-1"></a>starting at landmark point $x_i$ that terminate at landmark point</span>
<span id="cb5-1021"><a href="#cb5-1021" aria-hidden="true" tabindex="-1"></a>$x_j$ . This has some resemblance to the way Isomap measures pairwise</span>
<span id="cb5-1022"><a href="#cb5-1022" aria-hidden="true" tabindex="-1"></a>distances between points. However, as in diffusion maps</span>
<span id="cb5-1023"><a href="#cb5-1023" aria-hidden="true" tabindex="-1"></a>@lafon:diffusion,@nadler:diffusion, rather than looking</span>
<span id="cb5-1024"><a href="#cb5-1024" aria-hidden="true" tabindex="-1"></a>for the shortest path through the neighborhood graph, the random</span>
<span id="cb5-1025"><a href="#cb5-1025" aria-hidden="true" tabindex="-1"></a>walk-based affinity measure integrates over all paths through the</span>
<span id="cb5-1026"><a href="#cb5-1026" aria-hidden="true" tabindex="-1"></a>neighborhood graph. As a result, the random walk-based affinity</span>
<span id="cb5-1027"><a href="#cb5-1027" aria-hidden="true" tabindex="-1"></a>measure is much less sensitive to "short-circuits"</span>
<span id="cb5-1028"><a href="#cb5-1028" aria-hidden="true" tabindex="-1"></a>@lee:nonlinear2005, in which a single noisy datapoint provides a</span>
<span id="cb5-1029"><a href="#cb5-1029" aria-hidden="true" tabindex="-1"></a>bridge between two regions of dataspace that should be far apart in</span>
<span id="cb5-1030"><a href="#cb5-1030" aria-hidden="true" tabindex="-1"></a>the map. Similar approaches using random walks have also been</span>
<span id="cb5-1031"><a href="#cb5-1031" aria-hidden="true" tabindex="-1"></a>successfully applied to, for example, semi-supervised learning</span>
<span id="cb5-1032"><a href="#cb5-1032" aria-hidden="true" tabindex="-1"></a>@jaakola:partially,@zhu:semi and image segmentation</span>
<span id="cb5-1033"><a href="#cb5-1033" aria-hidden="true" tabindex="-1"></a>@grady:random.</span>
<span id="cb5-1034"><a href="#cb5-1034" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1035"><a href="#cb5-1035" aria-hidden="true" tabindex="-1"></a>The most obvious way to compute the random walk-based similarities</span>
<span id="cb5-1036"><a href="#cb5-1036" aria-hidden="true" tabindex="-1"></a>$p_{j|i}$ is to explicitly perform the random walks on the</span>
<span id="cb5-1037"><a href="#cb5-1037" aria-hidden="true" tabindex="-1"></a>neighborhood graph, which works very well in practice, given that one</span>
<span id="cb5-1038"><a href="#cb5-1038" aria-hidden="true" tabindex="-1"></a>can easily perform one million random walks per second. Alternatively,</span>
<span id="cb5-1039"><a href="#cb5-1039" aria-hidden="true" tabindex="-1"></a>@grady:random presents an analytical solution to compute the</span>
<span id="cb5-1040"><a href="#cb5-1040" aria-hidden="true" tabindex="-1"></a>pairwise similarities $p_{j|i}$ that involves solving a sparse linear</span>
<span id="cb5-1041"><a href="#cb5-1041" aria-hidden="true" tabindex="-1"></a>system. The analytical solution to compute the similarities $p_{j|i}$</span>
<span id="cb5-1042"><a href="#cb5-1042" aria-hidden="true" tabindex="-1"></a>is sketched in Appendix B (FIXME). In preliminary experiments, we did not find</span>
<span id="cb5-1043"><a href="#cb5-1043" aria-hidden="true" tabindex="-1"></a>significant differences between performing the random walks explicitly</span>
<span id="cb5-1044"><a href="#cb5-1044" aria-hidden="true" tabindex="-1"></a>and the analytical solution. In the experiment we present below, we</span>
<span id="cb5-1045"><a href="#cb5-1045" aria-hidden="true" tabindex="-1"></a>explicitly performed the random walks because this is computationally</span>
<span id="cb5-1046"><a href="#cb5-1046" aria-hidden="true" tabindex="-1"></a>less expensive. However, for very large data sets in which the</span>
<span id="cb5-1047"><a href="#cb5-1047" aria-hidden="true" tabindex="-1"></a>landmark points are very sparse, the analytical solution may be more</span>
<span id="cb5-1048"><a href="#cb5-1048" aria-hidden="true" tabindex="-1"></a>appropriate.</span>
<span id="cb5-1049"><a href="#cb5-1049" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1050"><a href="#cb5-1050" aria-hidden="true" tabindex="-1"></a>::: {#fig-random-walk-tsne} </span>
<span id="cb5-1051"><a href="#cb5-1051" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1052"><a href="#cb5-1052" aria-hidden="true" tabindex="-1"></a><span class="al">![](figures/random-walk-tSNE.png)</span></span>
<span id="cb5-1053"><a href="#cb5-1053" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1054"><a href="#cb5-1054" aria-hidden="true" tabindex="-1"></a>Visualization of 6,000 digits from the MNIST data set produced by the random walk</span>
<span id="cb5-1055"><a href="#cb5-1055" aria-hidden="true" tabindex="-1"></a>version of t-SNE (employing all 60,000 digit images).</span>
<span id="cb5-1056"><a href="#cb5-1056" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1057"><a href="#cb5-1057" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">Note of the editor</span><span class="co">]</span> Please note that this dataset is too large for the code</span>
<span id="cb5-1058"><a href="#cb5-1058" aria-hidden="true" tabindex="-1"></a>to be processed through continuous integration. You can find the code to</span>
<span id="cb5-1059"><a href="#cb5-1059" aria-hidden="true" tabindex="-1"></a>reproduce this plot on</span>
<span id="cb5-1060"><a href="#cb5-1060" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">github</span><span class="co">](https://github.com/computorg/published-paper-tsne/tree/main/scripts)</span></span>
<span id="cb5-1061"><a href="#cb5-1061" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1062"><a href="#cb5-1062" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb5-1063"><a href="#cb5-1063" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1064"><a href="#cb5-1064" aria-hidden="true" tabindex="-1"></a>@fig-random-walk-tsne shows the results of an experiment, in which we</span>
<span id="cb5-1065"><a href="#cb5-1065" aria-hidden="true" tabindex="-1"></a>applied the random walk version of t-SNE to 6,000 randomly selected</span>
<span id="cb5-1066"><a href="#cb5-1066" aria-hidden="true" tabindex="-1"></a>digits from the MNIST data set, using all 60,000 digits to compute the</span>
<span id="cb5-1067"><a href="#cb5-1067" aria-hidden="true" tabindex="-1"></a>pairwise affinities $p_{j|i}$. In the experiment, we used a</span>
<span id="cb5-1068"><a href="#cb5-1068" aria-hidden="true" tabindex="-1"></a>neighborhood graph that was constructed using a value of $k = 20$</span>
<span id="cb5-1069"><a href="#cb5-1069" aria-hidden="true" tabindex="-1"></a>nearest neighbors.<span class="ot">[^knn]</span> The inset of the figure shows the same</span>
<span id="cb5-1070"><a href="#cb5-1070" aria-hidden="true" tabindex="-1"></a>visualization as a scatterplot in which the colors represent the</span>
<span id="cb5-1071"><a href="#cb5-1071" aria-hidden="true" tabindex="-1"></a>labels of the digits. In the t-SNE map, all classes are clearly</span>
<span id="cb5-1072"><a href="#cb5-1072" aria-hidden="true" tabindex="-1"></a>separated and the "continental" sevens form a small separate cluster.</span>
<span id="cb5-1073"><a href="#cb5-1073" aria-hidden="true" tabindex="-1"></a>Moreover, t-SNE reveals the main dimensions of variation within each</span>
<span id="cb5-1074"><a href="#cb5-1074" aria-hidden="true" tabindex="-1"></a>class, such as the orientation of the ones, fours, sevens, and nines,</span>
<span id="cb5-1075"><a href="#cb5-1075" aria-hidden="true" tabindex="-1"></a>or the "loopiness" of the twos. The strong performance of t-SNE is</span>
<span id="cb5-1076"><a href="#cb5-1076" aria-hidden="true" tabindex="-1"></a>also reflected in the generalization error of nearest neighbor</span>
<span id="cb5-1077"><a href="#cb5-1077" aria-hidden="true" tabindex="-1"></a>classifiers that are trained on the low-dimensional</span>
<span id="cb5-1078"><a href="#cb5-1078" aria-hidden="true" tabindex="-1"></a>representation. Whereas the generalization error (measured using</span>
<span id="cb5-1079"><a href="#cb5-1079" aria-hidden="true" tabindex="-1"></a>10-fold cross validation) of a 1-nearest neighbor classifier trained</span>
<span id="cb5-1080"><a href="#cb5-1080" aria-hidden="true" tabindex="-1"></a>on the original 784-dimensional datapoints is 5.75%, the</span>
<span id="cb5-1081"><a href="#cb5-1081" aria-hidden="true" tabindex="-1"></a>generalization error of a 1-nearest neighbor classifier trained on the</span>
<span id="cb5-1082"><a href="#cb5-1082" aria-hidden="true" tabindex="-1"></a>two-dimensional data representation produced by t-SNE is only</span>
<span id="cb5-1083"><a href="#cb5-1083" aria-hidden="true" tabindex="-1"></a>5.13%. The computational requirements of random walk t-SNE are</span>
<span id="cb5-1084"><a href="#cb5-1084" aria-hidden="true" tabindex="-1"></a>reasonable: it took only one hour of CPU time to construct the map in</span>
<span id="cb5-1085"><a href="#cb5-1085" aria-hidden="true" tabindex="-1"></a>@fig-random-walk-tsne.</span>
<span id="cb5-1086"><a href="#cb5-1086" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1087"><a href="#cb5-1087" aria-hidden="true" tabindex="-1"></a><span class="ot">[^knn]: </span>In preliminary experiments, we found the performance of random</span>
<span id="cb5-1088"><a href="#cb5-1088" aria-hidden="true" tabindex="-1"></a>    walk t-SNE to be very robust under changes of $k$.</span>
<span id="cb5-1089"><a href="#cb5-1089" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1090"><a href="#cb5-1090" aria-hidden="true" tabindex="-1"></a><span class="fu"># Discussion {#sec-discussion}</span></span>
<span id="cb5-1091"><a href="#cb5-1091" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1092"><a href="#cb5-1092" aria-hidden="true" tabindex="-1"></a>The results in the previous two sections (and those in the</span>
<span id="cb5-1093"><a href="#cb5-1093" aria-hidden="true" tabindex="-1"></a>supplemental material) demonstrate the performance of t-SNE on a wide</span>
<span id="cb5-1094"><a href="#cb5-1094" aria-hidden="true" tabindex="-1"></a>variety of data sets. In this section, we discuss the differences</span>
<span id="cb5-1095"><a href="#cb5-1095" aria-hidden="true" tabindex="-1"></a>between t-SNE and other non-parametric techniques</span>
<span id="cb5-1096"><a href="#cb5-1096" aria-hidden="true" tabindex="-1"></a>(<span class="co">[</span><span class="ot"> 6.1</span><span class="co">](sec-comparison)</span>), and we also discuss a number of</span>
<span id="cb5-1097"><a href="#cb5-1097" aria-hidden="true" tabindex="-1"></a>weaknesses and possible improvements of t-SNE</span>
<span id="cb5-1098"><a href="#cb5-1098" aria-hidden="true" tabindex="-1"></a>(<span class="co">[</span><span class="ot"> 6.2</span><span class="co">](sec-weakness)</span>).</span>
<span id="cb5-1099"><a href="#cb5-1099" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1100"><a href="#cb5-1100" aria-hidden="true" tabindex="-1"></a><span class="fu">## Comparison with Related Techniques {#sec-comparison}</span></span>
<span id="cb5-1101"><a href="#cb5-1101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1102"><a href="#cb5-1102" aria-hidden="true" tabindex="-1"></a>Classical scaling @torgerson:multidimensional, which is closely</span>
<span id="cb5-1103"><a href="#cb5-1103" aria-hidden="true" tabindex="-1"></a>related to PCA @mardia:multivariate</span>
<span id="cb5-1104"><a href="#cb5-1104" aria-hidden="true" tabindex="-1"></a>@williams:connection, finds a linear transformation of the data</span>
<span id="cb5-1105"><a href="#cb5-1105" aria-hidden="true" tabindex="-1"></a>that minimizes the sum of the squared errors between high-dimensional</span>
<span id="cb5-1106"><a href="#cb5-1106" aria-hidden="true" tabindex="-1"></a>pairwise distances and their low-dimensional representatives. A linear</span>
<span id="cb5-1107"><a href="#cb5-1107" aria-hidden="true" tabindex="-1"></a>method such as classical scaling is not good at modeling curved</span>
<span id="cb5-1108"><a href="#cb5-1108" aria-hidden="true" tabindex="-1"></a>manifolds and it focuses on preserving the distances between widely</span>
<span id="cb5-1109"><a href="#cb5-1109" aria-hidden="true" tabindex="-1"></a>separated datapoints rather than on preserving the distances between</span>
<span id="cb5-1110"><a href="#cb5-1110" aria-hidden="true" tabindex="-1"></a>nearby datapoints. An important approach that attempts to address the</span>
<span id="cb5-1111"><a href="#cb5-1111" aria-hidden="true" tabindex="-1"></a>problems of classical scaling is the Sammon mapping</span>
<span id="cb5-1112"><a href="#cb5-1112" aria-hidden="true" tabindex="-1"></a>@sammon:nonlinear which alters the cost function of classical</span>
<span id="cb5-1113"><a href="#cb5-1113" aria-hidden="true" tabindex="-1"></a>scaling by dividing the squared error in the representation of each</span>
<span id="cb5-1114"><a href="#cb5-1114" aria-hidden="true" tabindex="-1"></a>pairwise Euclidean distance by the original Euclidean distance in the</span>
<span id="cb5-1115"><a href="#cb5-1115" aria-hidden="true" tabindex="-1"></a>high-dimensional space. The resulting cost function is given by</span>
<span id="cb5-1116"><a href="#cb5-1116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1117"><a href="#cb5-1117" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1118"><a href="#cb5-1118" aria-hidden="true" tabindex="-1"></a>    C = \frac{1}{\sum_{ij} \|x_i - x_j\|} \sum_{i \neq j} \frac{\left(\|x_i - x_j\| - \|x_i - x_j\|\right)^2}{\|x_i - x_j\|}\,</span>
<span id="cb5-1119"><a href="#cb5-1119" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1120"><a href="#cb5-1120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1121"><a href="#cb5-1121" aria-hidden="true" tabindex="-1"></a>where the constant outside of the sum is added in order to simplify</span>
<span id="cb5-1122"><a href="#cb5-1122" aria-hidden="true" tabindex="-1"></a>the derivation of the gradient.  The main weakness of the Sammon cost</span>
<span id="cb5-1123"><a href="#cb5-1123" aria-hidden="true" tabindex="-1"></a>function is that the importance of retaining small pairwise distances</span>
<span id="cb5-1124"><a href="#cb5-1124" aria-hidden="true" tabindex="-1"></a>in the map is largely dependent on small differences in these pairwise</span>
<span id="cb5-1125"><a href="#cb5-1125" aria-hidden="true" tabindex="-1"></a>distances. In particular, a small error in the model of two</span>
<span id="cb5-1126"><a href="#cb5-1126" aria-hidden="true" tabindex="-1"></a>high-dimensional points that are extremely close together results in a</span>
<span id="cb5-1127"><a href="#cb5-1127" aria-hidden="true" tabindex="-1"></a>large contribution to the cost function. Since all small pairwise</span>
<span id="cb5-1128"><a href="#cb5-1128" aria-hidden="true" tabindex="-1"></a>distances constitute the local structure of the data, it seems more</span>
<span id="cb5-1129"><a href="#cb5-1129" aria-hidden="true" tabindex="-1"></a>appropriate to aim to assign approximately equal importance to all</span>
<span id="cb5-1130"><a href="#cb5-1130" aria-hidden="true" tabindex="-1"></a>small pairwise distances.</span>
<span id="cb5-1131"><a href="#cb5-1131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1132"><a href="#cb5-1132" aria-hidden="true" tabindex="-1"></a>In contrast to Sammon mapping, the Gaussian kernel employed in the</span>
<span id="cb5-1133"><a href="#cb5-1133" aria-hidden="true" tabindex="-1"></a>high-dimensional space by t-SNE defines a soft border between the</span>
<span id="cb5-1134"><a href="#cb5-1134" aria-hidden="true" tabindex="-1"></a>local and global structure of the data and for pairs of datapoints</span>
<span id="cb5-1135"><a href="#cb5-1135" aria-hidden="true" tabindex="-1"></a>that are close together relative to the standard deviation of the</span>
<span id="cb5-1136"><a href="#cb5-1136" aria-hidden="true" tabindex="-1"></a>Gaussian, the importance of modeling their separations is almost</span>
<span id="cb5-1137"><a href="#cb5-1137" aria-hidden="true" tabindex="-1"></a>independent of the magnitudes of those separations. Moreover, t-SNE</span>
<span id="cb5-1138"><a href="#cb5-1138" aria-hidden="true" tabindex="-1"></a>determines the local neighborhood size for each datapoint separately</span>
<span id="cb5-1139"><a href="#cb5-1139" aria-hidden="true" tabindex="-1"></a>based on the local density of the data (by forcing each conditional</span>
<span id="cb5-1140"><a href="#cb5-1140" aria-hidden="true" tabindex="-1"></a>probability distribution $P_i$ to have the same perplexity).</span>
<span id="cb5-1141"><a href="#cb5-1141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1142"><a href="#cb5-1142" aria-hidden="true" tabindex="-1"></a>The strong performance of t-SNE compared to Isomap is partly explained</span>
<span id="cb5-1143"><a href="#cb5-1143" aria-hidden="true" tabindex="-1"></a>by Isomap’s susceptibility to “short-circuiting”. Also, Isomap mainly</span>
<span id="cb5-1144"><a href="#cb5-1144" aria-hidden="true" tabindex="-1"></a>focuses on modeling large geodesic distances rather than small ones.</span>
<span id="cb5-1145"><a href="#cb5-1145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1146"><a href="#cb5-1146" aria-hidden="true" tabindex="-1"></a>The strong performance of t-SNE compared to LLE is mainly due to a</span>
<span id="cb5-1147"><a href="#cb5-1147" aria-hidden="true" tabindex="-1"></a>basic weakness of LLE: the only thing that prevents all datapoints</span>
<span id="cb5-1148"><a href="#cb5-1148" aria-hidden="true" tabindex="-1"></a>from collapsing onto a single point is a constraint on the covariance</span>
<span id="cb5-1149"><a href="#cb5-1149" aria-hidden="true" tabindex="-1"></a>of the low-dimensional representation. In practice, this constraint is</span>
<span id="cb5-1150"><a href="#cb5-1150" aria-hidden="true" tabindex="-1"></a>often satisfied by placing most of the map points near the center of</span>
<span id="cb5-1151"><a href="#cb5-1151" aria-hidden="true" tabindex="-1"></a>the map and using a few widely scattered points to create large</span>
<span id="cb5-1152"><a href="#cb5-1152" aria-hidden="true" tabindex="-1"></a>covariance (see Figure FIXME). For neighborhood graphs that are almost</span>
<span id="cb5-1153"><a href="#cb5-1153" aria-hidden="true" tabindex="-1"></a>disconnected, the covariance constraint can also be satisfied by a</span>
<span id="cb5-1154"><a href="#cb5-1154" aria-hidden="true" tabindex="-1"></a>“curdled” map in which there are a few widely separated, collapsed</span>
<span id="cb5-1155"><a href="#cb5-1155" aria-hidden="true" tabindex="-1"></a>subsets corresponding to the almost disconnected components.</span>
<span id="cb5-1156"><a href="#cb5-1156" aria-hidden="true" tabindex="-1"></a>Furthermore, neighborhood-graph based techniques (such as Isomap and</span>
<span id="cb5-1157"><a href="#cb5-1157" aria-hidden="true" tabindex="-1"></a>LLE) are not capable of visualizing data that consists of two or more</span>
<span id="cb5-1158"><a href="#cb5-1158" aria-hidden="true" tabindex="-1"></a>widely separated submanifolds, because such data does not give rise to</span>
<span id="cb5-1159"><a href="#cb5-1159" aria-hidden="true" tabindex="-1"></a>a connected neighborhood graph. It is possible to produce a separate</span>
<span id="cb5-1160"><a href="#cb5-1160" aria-hidden="true" tabindex="-1"></a>map for each connected component, but this loses information about the</span>
<span id="cb5-1161"><a href="#cb5-1161" aria-hidden="true" tabindex="-1"></a>relative similarities of the separate components.</span>
<span id="cb5-1162"><a href="#cb5-1162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1163"><a href="#cb5-1163" aria-hidden="true" tabindex="-1"></a>Like Isomap and LLE, the random walk version of t-SNE employs</span>
<span id="cb5-1164"><a href="#cb5-1164" aria-hidden="true" tabindex="-1"></a>neighborhood graphs, but it does not suffer from short-circuiting</span>
<span id="cb5-1165"><a href="#cb5-1165" aria-hidden="true" tabindex="-1"></a>problems because the pairwise similarities between the highdimensional</span>
<span id="cb5-1166"><a href="#cb5-1166" aria-hidden="true" tabindex="-1"></a>datapoints are computed by integrating over all paths through the</span>
<span id="cb5-1167"><a href="#cb5-1167" aria-hidden="true" tabindex="-1"></a>neighborhood graph.  Because of the diffusion-based interpretation of</span>
<span id="cb5-1168"><a href="#cb5-1168" aria-hidden="true" tabindex="-1"></a>the conditional probabilities underlying the random walk version of</span>
<span id="cb5-1169"><a href="#cb5-1169" aria-hidden="true" tabindex="-1"></a>t-SNE, it is useful to compare t-SNE to diffusion maps. Diffusion maps</span>
<span id="cb5-1170"><a href="#cb5-1170" aria-hidden="true" tabindex="-1"></a>define a "diffusion distance" on the high-dimensional datapoints that</span>
<span id="cb5-1171"><a href="#cb5-1171" aria-hidden="true" tabindex="-1"></a>is given by</span>
<span id="cb5-1172"><a href="#cb5-1172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1173"><a href="#cb5-1173" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb5-1174"><a href="#cb5-1174" aria-hidden="true" tabindex="-1"></a>D^{(t)}(x_i,x_j) = \sqrt{ \sum_{k} \frac{\left(p^{(t)}_{ik} -</span>
<span id="cb5-1175"><a href="#cb5-1175" aria-hidden="true" tabindex="-1"></a>p^{(t)}_{jk}\right)^2)}{\psi(x_k)^{(0)}} }\,</span>
<span id="cb5-1176"><a href="#cb5-1176" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1177"><a href="#cb5-1177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1178"><a href="#cb5-1178" aria-hidden="true" tabindex="-1"></a>where $p^{(t)}_{ij}$ represents the probability of a particle</span>
<span id="cb5-1179"><a href="#cb5-1179" aria-hidden="true" tabindex="-1"></a>traveling from $x_i$ to $x_j$ in $t$ timesteps through a graph on the</span>
<span id="cb5-1180"><a href="#cb5-1180" aria-hidden="true" tabindex="-1"></a>data with Gaussian emission probabilities. The term $\psi(x_k)^{(0)}$</span>
<span id="cb5-1181"><a href="#cb5-1181" aria-hidden="true" tabindex="-1"></a>is a measure for the local density of the points, and serves a similar</span>
<span id="cb5-1182"><a href="#cb5-1182" aria-hidden="true" tabindex="-1"></a>purpose to the fixed perplexity Gaussian kernel that is employed in</span>
<span id="cb5-1183"><a href="#cb5-1183" aria-hidden="true" tabindex="-1"></a>SNE. The diffusion map is formed by the principal non-trivial</span>
<span id="cb5-1184"><a href="#cb5-1184" aria-hidden="true" tabindex="-1"></a>eigenvectors of the Markov matrix of the random walks of length</span>
<span id="cb5-1185"><a href="#cb5-1185" aria-hidden="true" tabindex="-1"></a>$t$. It can be shown that when all $(n−1)$ non-trivial eigenvectors</span>
<span id="cb5-1186"><a href="#cb5-1186" aria-hidden="true" tabindex="-1"></a>are employed, the Euclidean distances in the diffusion map are equal</span>
<span id="cb5-1187"><a href="#cb5-1187" aria-hidden="true" tabindex="-1"></a>to the diffusion distances in the high-dimensional data representation</span>
<span id="cb5-1188"><a href="#cb5-1188" aria-hidden="true" tabindex="-1"></a>@lafon:diffusion. Mathematically, diffusion maps minimize</span>
<span id="cb5-1189"><a href="#cb5-1189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1190"><a href="#cb5-1190" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1191"><a href="#cb5-1191" aria-hidden="true" tabindex="-1"></a>C = \sum_i \sum_j \left(D^{(t)}(x_i,x_j) - \|y_i-y_j\|\right)^2</span>
<span id="cb5-1192"><a href="#cb5-1192" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1193"><a href="#cb5-1193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1194"><a href="#cb5-1194" aria-hidden="true" tabindex="-1"></a>As a result, diffusion maps are susceptible to the same problems as</span>
<span id="cb5-1195"><a href="#cb5-1195" aria-hidden="true" tabindex="-1"></a>classical scaling: they assign much higher importance to modeling the</span>
<span id="cb5-1196"><a href="#cb5-1196" aria-hidden="true" tabindex="-1"></a>large pairwise diffusion distances than the small ones and as a</span>
<span id="cb5-1197"><a href="#cb5-1197" aria-hidden="true" tabindex="-1"></a>result, they are not good at retaining the local structure of the</span>
<span id="cb5-1198"><a href="#cb5-1198" aria-hidden="true" tabindex="-1"></a>data. Moreover, in contrast to the random walk version of t-SNE,</span>
<span id="cb5-1199"><a href="#cb5-1199" aria-hidden="true" tabindex="-1"></a>diffusion maps do not have a natural way of selecting the length, $t$,</span>
<span id="cb5-1200"><a href="#cb5-1200" aria-hidden="true" tabindex="-1"></a>of the random walks.</span>
<span id="cb5-1201"><a href="#cb5-1201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1202"><a href="#cb5-1202" aria-hidden="true" tabindex="-1"></a>In the supplemental material, we present results that reveal that</span>
<span id="cb5-1203"><a href="#cb5-1203" aria-hidden="true" tabindex="-1"></a>t-SNE outperforms CCA @demartines:curvilinear, MVU</span>
<span id="cb5-1204"><a href="#cb5-1204" aria-hidden="true" tabindex="-1"></a>@weinberger:learning, and Laplacian Eigenmaps</span>
<span id="cb5-1205"><a href="#cb5-1205" aria-hidden="true" tabindex="-1"></a>@belkin:laplacian as well. For CCA and the closely related CDA</span>
<span id="cb5-1206"><a href="#cb5-1206" aria-hidden="true" tabindex="-1"></a>@lee:robust, these results can be partially explained by the</span>
<span id="cb5-1207"><a href="#cb5-1207" aria-hidden="true" tabindex="-1"></a>hard border $\lambda$ that these techniques define between local and global</span>
<span id="cb5-1208"><a href="#cb5-1208" aria-hidden="true" tabindex="-1"></a>structure, as opposed to the soft border of t-SNE. Moreover, within</span>
<span id="cb5-1209"><a href="#cb5-1209" aria-hidden="true" tabindex="-1"></a>the range $\lambda$, CCA suffers from the same weakness as Sammon mapping: it</span>
<span id="cb5-1210"><a href="#cb5-1210" aria-hidden="true" tabindex="-1"></a>assigns extremely high importance to modeling the distance between two</span>
<span id="cb5-1211"><a href="#cb5-1211" aria-hidden="true" tabindex="-1"></a>datapoints that are extremely close.</span>
<span id="cb5-1212"><a href="#cb5-1212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1213"><a href="#cb5-1213" aria-hidden="true" tabindex="-1"></a>Like t-SNE, MVU @weinberger:learning tries to model all of the</span>
<span id="cb5-1214"><a href="#cb5-1214" aria-hidden="true" tabindex="-1"></a>small separations well but MVU insists on modeling them perfectly</span>
<span id="cb5-1215"><a href="#cb5-1215" aria-hidden="true" tabindex="-1"></a>(i.e., it treats them as constraints) and a single erroneous</span>
<span id="cb5-1216"><a href="#cb5-1216" aria-hidden="true" tabindex="-1"></a>constraint may severely affect the performance of MVU. This can occur</span>
<span id="cb5-1217"><a href="#cb5-1217" aria-hidden="true" tabindex="-1"></a>when there is a short-circuit between two parts of a curved manifold</span>
<span id="cb5-1218"><a href="#cb5-1218" aria-hidden="true" tabindex="-1"></a>that are far apart in the intrinsic manifold coordinates. Also, MVU</span>
<span id="cb5-1219"><a href="#cb5-1219" aria-hidden="true" tabindex="-1"></a>makes no attempt to model longer range structure: It simply pulls the</span>
<span id="cb5-1220"><a href="#cb5-1220" aria-hidden="true" tabindex="-1"></a>map points as far apart as possible subject to the hard constraints</span>
<span id="cb5-1221"><a href="#cb5-1221" aria-hidden="true" tabindex="-1"></a>so, unlike t-SNE, it cannot be expected to produce sensible</span>
<span id="cb5-1222"><a href="#cb5-1222" aria-hidden="true" tabindex="-1"></a>large-scale structure in the map.</span>
<span id="cb5-1223"><a href="#cb5-1223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1224"><a href="#cb5-1224" aria-hidden="true" tabindex="-1"></a>For Laplacian Eigenmaps, the poor results relative to t-SNE may be</span>
<span id="cb5-1225"><a href="#cb5-1225" aria-hidden="true" tabindex="-1"></a>explained by the fact that Laplacian Eigenmaps have the same</span>
<span id="cb5-1226"><a href="#cb5-1226" aria-hidden="true" tabindex="-1"></a>covariance constraint as LLE, and it is easy to cheat on this</span>
<span id="cb5-1227"><a href="#cb5-1227" aria-hidden="true" tabindex="-1"></a>constraint.</span>
<span id="cb5-1228"><a href="#cb5-1228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1229"><a href="#cb5-1229" aria-hidden="true" tabindex="-1"></a><span class="fu">## Weakness {#sec-weakness}</span></span>
<span id="cb5-1230"><a href="#cb5-1230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1231"><a href="#cb5-1231" aria-hidden="true" tabindex="-1"></a>Although we have shown that t-SNE comparesfavorably to other</span>
<span id="cb5-1232"><a href="#cb5-1232" aria-hidden="true" tabindex="-1"></a>techniquesfor data visualization, tSNE has three potential weaknesses:</span>
<span id="cb5-1233"><a href="#cb5-1233" aria-hidden="true" tabindex="-1"></a>(1) it is unclear how t-SNE performs on general dimensionality</span>
<span id="cb5-1234"><a href="#cb5-1234" aria-hidden="true" tabindex="-1"></a>reduction tasks, (2) the relatively local nature of t-SNE makes it</span>
<span id="cb5-1235"><a href="#cb5-1235" aria-hidden="true" tabindex="-1"></a>sensitive to the curse of the intrinsic dimensionality of the data,</span>
<span id="cb5-1236"><a href="#cb5-1236" aria-hidden="true" tabindex="-1"></a>and (3) t-SNE is not guaranteed to converge to a global optimum of its</span>
<span id="cb5-1237"><a href="#cb5-1237" aria-hidden="true" tabindex="-1"></a>cost function. Below, we discuss the three weaknesses in more detail.</span>
<span id="cb5-1238"><a href="#cb5-1238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1239"><a href="#cb5-1239" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>*Dimensionality reduction for other purposes.* It is not obvious</span>
<span id="cb5-1240"><a href="#cb5-1240" aria-hidden="true" tabindex="-1"></a>how t-SNE will perform on the more general task of dimensionality</span>
<span id="cb5-1241"><a href="#cb5-1241" aria-hidden="true" tabindex="-1"></a>reduction (i.e., when the dimensionality of the data is not reduced to</span>
<span id="cb5-1242"><a href="#cb5-1242" aria-hidden="true" tabindex="-1"></a>two or three, but to $d &gt; 3$ dimensions). To simplify evaluation issues,</span>
<span id="cb5-1243"><a href="#cb5-1243" aria-hidden="true" tabindex="-1"></a>this paper only considers the use of t-SNE for data visualization. The</span>
<span id="cb5-1244"><a href="#cb5-1244" aria-hidden="true" tabindex="-1"></a>behavior of t-SNE when reducing data to two or three dimensions cannot</span>
<span id="cb5-1245"><a href="#cb5-1245" aria-hidden="true" tabindex="-1"></a>readily be extrapolated to $d &gt; 3$ dimensions because of the heavy tails</span>
<span id="cb5-1246"><a href="#cb5-1246" aria-hidden="true" tabindex="-1"></a>of the Student-t distribution. In high-dimensional spaces, the heavy</span>
<span id="cb5-1247"><a href="#cb5-1247" aria-hidden="true" tabindex="-1"></a>tails comprise a relatively large portion of the probability mass</span>
<span id="cb5-1248"><a href="#cb5-1248" aria-hidden="true" tabindex="-1"></a>under the Student-t distribution, which might lead to d-dimensional</span>
<span id="cb5-1249"><a href="#cb5-1249" aria-hidden="true" tabindex="-1"></a>data representations that do not preserve the local structure of the</span>
<span id="cb5-1250"><a href="#cb5-1250" aria-hidden="true" tabindex="-1"></a>data as well. Hence, for tasks in which the dimensionality of the data</span>
<span id="cb5-1251"><a href="#cb5-1251" aria-hidden="true" tabindex="-1"></a>needs to be reduced to a dimensionality higher than three, Student</span>
<span id="cb5-1252"><a href="#cb5-1252" aria-hidden="true" tabindex="-1"></a>t-distributions with more than one degree of freedom10 are likely to</span>
<span id="cb5-1253"><a href="#cb5-1253" aria-hidden="true" tabindex="-1"></a>be more appropriate.</span>
<span id="cb5-1254"><a href="#cb5-1254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1255"><a href="#cb5-1255" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>*Curse of intrinsic dimensionality.* t-SNE reduces the</span>
<span id="cb5-1256"><a href="#cb5-1256" aria-hidden="true" tabindex="-1"></a>dimensionality of data mainly based on local properties of the data,</span>
<span id="cb5-1257"><a href="#cb5-1257" aria-hidden="true" tabindex="-1"></a>which makes t-SNE sensitive to the curse of the intrinsic</span>
<span id="cb5-1258"><a href="#cb5-1258" aria-hidden="true" tabindex="-1"></a>dimensionality of the data @bengio:learning. In data sets with</span>
<span id="cb5-1259"><a href="#cb5-1259" aria-hidden="true" tabindex="-1"></a>a high intrinsic dimensionality and an underlying manifold that is</span>
<span id="cb5-1260"><a href="#cb5-1260" aria-hidden="true" tabindex="-1"></a>highly varying, the local linearity assumption on the manifold that</span>
<span id="cb5-1261"><a href="#cb5-1261" aria-hidden="true" tabindex="-1"></a>t-SNE implicitly makes (by employing Euclidean distances between near</span>
<span id="cb5-1262"><a href="#cb5-1262" aria-hidden="true" tabindex="-1"></a>neighbors) may be violated. As a result, t-SNE might be less</span>
<span id="cb5-1263"><a href="#cb5-1263" aria-hidden="true" tabindex="-1"></a>successful if it is applied on data sets with a very high intrinsic</span>
<span id="cb5-1264"><a href="#cb5-1264" aria-hidden="true" tabindex="-1"></a>dimensionality (for instance, a recent study by @meytlis:face</span>
<span id="cb5-1265"><a href="#cb5-1265" aria-hidden="true" tabindex="-1"></a>estimates the space of images of faces to be constituted of</span>
<span id="cb5-1266"><a href="#cb5-1266" aria-hidden="true" tabindex="-1"></a>approximately 100 dimensions). Manifold learners such as Isomap and</span>
<span id="cb5-1267"><a href="#cb5-1267" aria-hidden="true" tabindex="-1"></a>LLE suffer from exactly the same problems (see, e.g.,</span>
<span id="cb5-1268"><a href="#cb5-1268" aria-hidden="true" tabindex="-1"></a>@bengio:learning; @vandermaaten:comparison ).  A</span>
<span id="cb5-1269"><a href="#cb5-1269" aria-hidden="true" tabindex="-1"></a>possible way to (partially) address this issue is by performing t-SNE</span>
<span id="cb5-1270"><a href="#cb5-1270" aria-hidden="true" tabindex="-1"></a>on a data representation obtained from a model that represents the</span>
<span id="cb5-1271"><a href="#cb5-1271" aria-hidden="true" tabindex="-1"></a>highly varying data manifold efficiently in a number of nonlinear</span>
<span id="cb5-1272"><a href="#cb5-1272" aria-hidden="true" tabindex="-1"></a>layers such as an autoencoder @hinton:reducing. Such deep-layer</span>
<span id="cb5-1273"><a href="#cb5-1273" aria-hidden="true" tabindex="-1"></a>architectures can represent complex nonlinear functions in a much</span>
<span id="cb5-1274"><a href="#cb5-1274" aria-hidden="true" tabindex="-1"></a>simpler way, and as a result, require fewer datapoints to learn an</span>
<span id="cb5-1275"><a href="#cb5-1275" aria-hidden="true" tabindex="-1"></a>appropriate solution (as is illustrated for a d-bits parity task by</span>
<span id="cb5-1276"><a href="#cb5-1276" aria-hidden="true" tabindex="-1"></a>@bengio:learning). Performing t-SNE on a data representation</span>
<span id="cb5-1277"><a href="#cb5-1277" aria-hidden="true" tabindex="-1"></a>produced by, for example, an autoencoder is likely to improve the</span>
<span id="cb5-1278"><a href="#cb5-1278" aria-hidden="true" tabindex="-1"></a>quality of the constructed visualizations, because autoencoders can</span>
<span id="cb5-1279"><a href="#cb5-1279" aria-hidden="true" tabindex="-1"></a>identify highly-varying manifolds better than a local method such as</span>
<span id="cb5-1280"><a href="#cb5-1280" aria-hidden="true" tabindex="-1"></a>t-SNE. However, the reader should note that it is by definition</span>
<span id="cb5-1281"><a href="#cb5-1281" aria-hidden="true" tabindex="-1"></a>impossible to fully represent the structure of intrinsically</span>
<span id="cb5-1282"><a href="#cb5-1282" aria-hidden="true" tabindex="-1"></a>high-dimensional data in two or three dimensions.</span>
<span id="cb5-1283"><a href="#cb5-1283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1284"><a href="#cb5-1284" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>*Non-convexity of the t-SNE cost function.* A nice property of most</span>
<span id="cb5-1285"><a href="#cb5-1285" aria-hidden="true" tabindex="-1"></a>state-of-the-art dimensionality reduction techniques (such as</span>
<span id="cb5-1286"><a href="#cb5-1286" aria-hidden="true" tabindex="-1"></a>classical scaling, Isomap, LLE, and diffusion maps) is the convexity</span>
<span id="cb5-1287"><a href="#cb5-1287" aria-hidden="true" tabindex="-1"></a>of their cost functions. A major weakness of t-SNE is that the cost</span>
<span id="cb5-1288"><a href="#cb5-1288" aria-hidden="true" tabindex="-1"></a>function is not convex, as a result of which several optimization</span>
<span id="cb5-1289"><a href="#cb5-1289" aria-hidden="true" tabindex="-1"></a>parameters need to be chosen. The constructed solutions depend on</span>
<span id="cb5-1290"><a href="#cb5-1290" aria-hidden="true" tabindex="-1"></a>these choices of optimization parameters and may be different each</span>
<span id="cb5-1291"><a href="#cb5-1291" aria-hidden="true" tabindex="-1"></a>time t-SNE is run from an initial random configuration of map</span>
<span id="cb5-1292"><a href="#cb5-1292" aria-hidden="true" tabindex="-1"></a>points. We have demonstrated that the same choice of optimization</span>
<span id="cb5-1293"><a href="#cb5-1293" aria-hidden="true" tabindex="-1"></a>parameters can be used for a variety of different visualization tasks,</span>
<span id="cb5-1294"><a href="#cb5-1294" aria-hidden="true" tabindex="-1"></a>and we found that the quality of the optima does not vary much from</span>
<span id="cb5-1295"><a href="#cb5-1295" aria-hidden="true" tabindex="-1"></a>run to run. Therefore, we think that the weakness of the optimization</span>
<span id="cb5-1296"><a href="#cb5-1296" aria-hidden="true" tabindex="-1"></a>method is insufficient reason to reject t-SNE in favor of methods that</span>
<span id="cb5-1297"><a href="#cb5-1297" aria-hidden="true" tabindex="-1"></a>lead to convex optimization problems but produce noticeably worse</span>
<span id="cb5-1298"><a href="#cb5-1298" aria-hidden="true" tabindex="-1"></a>visualizations. A local optimum of a cost function that accurately</span>
<span id="cb5-1299"><a href="#cb5-1299" aria-hidden="true" tabindex="-1"></a>captures what we want in a visualization is often preferable to the</span>
<span id="cb5-1300"><a href="#cb5-1300" aria-hidden="true" tabindex="-1"></a>global optimum of a cost function that fails to capture important</span>
<span id="cb5-1301"><a href="#cb5-1301" aria-hidden="true" tabindex="-1"></a>aspects of what we want. Moreover, the convexity of cost functions can</span>
<span id="cb5-1302"><a href="#cb5-1302" aria-hidden="true" tabindex="-1"></a>be misleading, because their optimization is often computationally</span>
<span id="cb5-1303"><a href="#cb5-1303" aria-hidden="true" tabindex="-1"></a>infeasible for large real-world data sets, prompting the use of</span>
<span id="cb5-1304"><a href="#cb5-1304" aria-hidden="true" tabindex="-1"></a>approximation techniques @desilva:global;</span>
<span id="cb5-1305"><a href="#cb5-1305" aria-hidden="true" tabindex="-1"></a>@weinberger:graph. Even for LLE and Laplacian Eigenmaps, the</span>
<span id="cb5-1306"><a href="#cb5-1306" aria-hidden="true" tabindex="-1"></a>optimization is performed using iterative Arnoldi</span>
<span id="cb5-1307"><a href="#cb5-1307" aria-hidden="true" tabindex="-1"></a>@arnoldi:principle or Jacobi-Davidson @fokkema:jacobi</span>
<span id="cb5-1308"><a href="#cb5-1308" aria-hidden="true" tabindex="-1"></a>methods, which may fail to find the global optimum due to convergence</span>
<span id="cb5-1309"><a href="#cb5-1309" aria-hidden="true" tabindex="-1"></a>problems.</span>
<span id="cb5-1310"><a href="#cb5-1310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1311"><a href="#cb5-1311" aria-hidden="true" tabindex="-1"></a><span class="fu"># Conclusions {#sec-conclusion}</span></span>
<span id="cb5-1312"><a href="#cb5-1312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1313"><a href="#cb5-1313" aria-hidden="true" tabindex="-1"></a>The paper presents a new technique for the visualization of similarity</span>
<span id="cb5-1314"><a href="#cb5-1314" aria-hidden="true" tabindex="-1"></a>data that is capable of retaining the local structure of the data</span>
<span id="cb5-1315"><a href="#cb5-1315" aria-hidden="true" tabindex="-1"></a>while also revealing some important global structure (such as clusters</span>
<span id="cb5-1316"><a href="#cb5-1316" aria-hidden="true" tabindex="-1"></a>at multiple scales). Both the computational and the memory complexity</span>
<span id="cb5-1317"><a href="#cb5-1317" aria-hidden="true" tabindex="-1"></a>of t-SNE are $\mathcal{O}(n^2)$, but we present a landmark approach</span>
<span id="cb5-1318"><a href="#cb5-1318" aria-hidden="true" tabindex="-1"></a>that makes it possible to successfully visualize large real-world data</span>
<span id="cb5-1319"><a href="#cb5-1319" aria-hidden="true" tabindex="-1"></a>sets with limited computational demands. Our experiments on a variety</span>
<span id="cb5-1320"><a href="#cb5-1320" aria-hidden="true" tabindex="-1"></a>of data sets show that t-SNE outperforms existing state-of-the-art</span>
<span id="cb5-1321"><a href="#cb5-1321" aria-hidden="true" tabindex="-1"></a>techniques for visualizing a variety of real-world data sets. Matlab</span>
<span id="cb5-1322"><a href="#cb5-1322" aria-hidden="true" tabindex="-1"></a>implementations of both the normal and the random walk version of</span>
<span id="cb5-1323"><a href="#cb5-1323" aria-hidden="true" tabindex="-1"></a>t-SNE are available for download at</span>
<span id="cb5-1324"><a href="#cb5-1324" aria-hidden="true" tabindex="-1"></a><span class="ot">&lt;https://lvdmaaten.github.io/tsne/&gt;</span>.  In future work we plan to</span>
<span id="cb5-1325"><a href="#cb5-1325" aria-hidden="true" tabindex="-1"></a>investigate the optimization of the number of degrees of freedom of</span>
<span id="cb5-1326"><a href="#cb5-1326" aria-hidden="true" tabindex="-1"></a>the Student-t distribution used in t-SNE. This may be helpful for</span>
<span id="cb5-1327"><a href="#cb5-1327" aria-hidden="true" tabindex="-1"></a>dimensionality reduction when the low-dimensional representation has</span>
<span id="cb5-1328"><a href="#cb5-1328" aria-hidden="true" tabindex="-1"></a>many dimensions. We will also investigate the extension of t-SNE to</span>
<span id="cb5-1329"><a href="#cb5-1329" aria-hidden="true" tabindex="-1"></a>models in which each high-dimensional datapoint is modeled by several</span>
<span id="cb5-1330"><a href="#cb5-1330" aria-hidden="true" tabindex="-1"></a>low-dimensional map points as in @cook:visualizing. Also, we</span>
<span id="cb5-1331"><a href="#cb5-1331" aria-hidden="true" tabindex="-1"></a>aim to develop a parametric version of t-SNE that allows for</span>
<span id="cb5-1332"><a href="#cb5-1332" aria-hidden="true" tabindex="-1"></a>generalization to held-out test data by using the t-SNE objective</span>
<span id="cb5-1333"><a href="#cb5-1333" aria-hidden="true" tabindex="-1"></a>function to train a multilayer neural network that provides an</span>
<span id="cb5-1334"><a href="#cb5-1334" aria-hidden="true" tabindex="-1"></a>explicit mapping to the low-dimensional space</span>
<span id="cb5-1335"><a href="#cb5-1335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1336"><a href="#cb5-1336" aria-hidden="true" tabindex="-1"></a><span class="fu"># Acknowledgments {.unnumbered}</span></span>
<span id="cb5-1337"><a href="#cb5-1337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1338"><a href="#cb5-1338" aria-hidden="true" tabindex="-1"></a>The authors thank Sam Roweis for many helpful discussions, Andriy Mnih</span>
<span id="cb5-1339"><a href="#cb5-1339" aria-hidden="true" tabindex="-1"></a>for supplying the wordfeatures data set, Ruslan Salakhutdinov for help</span>
<span id="cb5-1340"><a href="#cb5-1340" aria-hidden="true" tabindex="-1"></a>with the Netflix data set (results for these data sets are presented</span>
<span id="cb5-1341"><a href="#cb5-1341" aria-hidden="true" tabindex="-1"></a>in the supplemental material), and Guido de Croon for pointing us to</span>
<span id="cb5-1342"><a href="#cb5-1342" aria-hidden="true" tabindex="-1"></a>the analytical solution of the random walk probabilities.</span>
<span id="cb5-1343"><a href="#cb5-1343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1344"><a href="#cb5-1344" aria-hidden="true" tabindex="-1"></a>Laurens van der Maaten is supported by the CATCH-programme of the Dutch Scientific </span>
<span id="cb5-1345"><a href="#cb5-1345" aria-hidden="true" tabindex="-1"></a>Organization (NWO), project RICH (grant 640.002.401), and cooperates with RACM.  </span>
<span id="cb5-1346"><a href="#cb5-1346" aria-hidden="true" tabindex="-1"></a>Geoffrey Hinton is a fellow of the Canadian Institute for Advanced Research, and </span>
<span id="cb5-1347"><a href="#cb5-1347" aria-hidden="true" tabindex="-1"></a>is also supported by grants from NSERC and CFI and gifts from Google and Microsoft.</span>
<span id="cb5-1348"><a href="#cb5-1348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1349"><a href="#cb5-1349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1350"><a href="#cb5-1350" aria-hidden="true" tabindex="-1"></a><span class="fu"># References {.unnumbered}</span></span>
<span id="cb5-1351"><a href="#cb5-1351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1352"><a href="#cb5-1352" aria-hidden="true" tabindex="-1"></a>::: {#refs}</span>
<span id="cb5-1353"><a href="#cb5-1353" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb5-1354"><a href="#cb5-1354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1355"><a href="#cb5-1355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1356"><a href="#cb5-1356" aria-hidden="true" tabindex="-1"></a><span class="fu"># Appendix A: Derivation of the t-SNE gradient {.appendix .unnumbered}</span></span>
<span id="cb5-1357"><a href="#cb5-1357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1358"><a href="#cb5-1358" aria-hidden="true" tabindex="-1"></a>t-SNE minimizes the Kullback-Leibler divergence between the joint</span>
<span id="cb5-1359"><a href="#cb5-1359" aria-hidden="true" tabindex="-1"></a>probabilities $p_{ij}$ in the highdimensional space and the joint</span>
<span id="cb5-1360"><a href="#cb5-1360" aria-hidden="true" tabindex="-1"></a>probabilities $q_{ij}$ in the low-dimensional space. The values of</span>
<span id="cb5-1361"><a href="#cb5-1361" aria-hidden="true" tabindex="-1"></a>$p_{ij}$ are defined to be the symmetrized conditional probabilities,</span>
<span id="cb5-1362"><a href="#cb5-1362" aria-hidden="true" tabindex="-1"></a>whereas the values of $q_{ij}$ are obtained by means of a Student-t</span>
<span id="cb5-1363"><a href="#cb5-1363" aria-hidden="true" tabindex="-1"></a>distribution with one degree of freedom</span>
<span id="cb5-1364"><a href="#cb5-1364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1365"><a href="#cb5-1365" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1366"><a href="#cb5-1366" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb5-1367"><a href="#cb5-1367" aria-hidden="true" tabindex="-1"></a>p_{ij} &amp; = \frac{p_{j|i} + p_{i|j}}{2 n} <span class="sc">\\</span></span>
<span id="cb5-1368"><a href="#cb5-1368" aria-hidden="true" tabindex="-1"></a>q_{ij} &amp; = \frac{\left(1 + \|y_i - y_j \|^2\right)^{-1}}{\sum_{k\neq \ell} \left(1 + \|y_k - y_\ell \|^2\right)^{-1}}</span>
<span id="cb5-1369"><a href="#cb5-1369" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb5-1370"><a href="#cb5-1370" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1371"><a href="#cb5-1371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1372"><a href="#cb5-1372" aria-hidden="true" tabindex="-1"></a>where $p_{j|i}$ and $p_{i|j}$ are either obtained from Equation 1 or</span>
<span id="cb5-1373"><a href="#cb5-1373" aria-hidden="true" tabindex="-1"></a>from the random walk procedure described in @sec-large-data. The values of $p_{ii}$ and $q_{ii}$ are set to</span>
<span id="cb5-1374"><a href="#cb5-1374" aria-hidden="true" tabindex="-1"></a>zero. The Kullback-Leibler divergence between the two joint</span>
<span id="cb5-1375"><a href="#cb5-1375" aria-hidden="true" tabindex="-1"></a>probability distributions $P$ and $Q$ is given by</span>
<span id="cb5-1376"><a href="#cb5-1376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1377"><a href="#cb5-1377" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1378"><a href="#cb5-1378" aria-hidden="true" tabindex="-1"></a>C = KL(P \| Q) = \sum_i \sum_j p_{ij} \log \frac{p_{ij}}{q_{ij}}  = \sum_i \sum_j p_{ij} \log p_{ij} - p_{ij} \log q_{ij}.</span>
<span id="cb5-1379"><a href="#cb5-1379" aria-hidden="true" tabindex="-1"></a>$$ {#eq-appendixa1}</span>
<span id="cb5-1380"><a href="#cb5-1380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1381"><a href="#cb5-1381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1382"><a href="#cb5-1382" aria-hidden="true" tabindex="-1"></a>In order to make the derivation less cluttered, we define two</span>
<span id="cb5-1383"><a href="#cb5-1383" aria-hidden="true" tabindex="-1"></a>auxiliary variables $d_{ij}$ and $Z$ as follows</span>
<span id="cb5-1384"><a href="#cb5-1384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1385"><a href="#cb5-1385" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1386"><a href="#cb5-1386" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb5-1387"><a href="#cb5-1387" aria-hidden="true" tabindex="-1"></a>d_{ij} &amp; = \|y_i - y_j\|, <span class="sc">\\</span></span>
<span id="cb5-1388"><a href="#cb5-1388" aria-hidden="true" tabindex="-1"></a>Z &amp; = \sum_{k\neq \ell} \left(1 + d_{k\ell}^2 \right)^{-1}.</span>
<span id="cb5-1389"><a href="#cb5-1389" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb5-1390"><a href="#cb5-1390" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1391"><a href="#cb5-1391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1392"><a href="#cb5-1392" aria-hidden="true" tabindex="-1"></a>Note that if $y_i$ changes, the only pairwise distances that change</span>
<span id="cb5-1393"><a href="#cb5-1393" aria-hidden="true" tabindex="-1"></a>are $d_{ij}$ and $d_{ji}$ for all $j$. Hence, the gradient of the cost</span>
<span id="cb5-1394"><a href="#cb5-1394" aria-hidden="true" tabindex="-1"></a>function $C$ with respect to $y_i$ is given by</span>
<span id="cb5-1395"><a href="#cb5-1395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1396"><a href="#cb5-1396" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1397"><a href="#cb5-1397" aria-hidden="true" tabindex="-1"></a>\frac{\partial C}{\partial y_i} = \sum_j \left(\frac{\partial C}{\partial d_{ij}} + \frac{\partial C}{\partial d_{ji}}\right) (y_i - y_j) = 2 \sum_j \frac{\partial C}{\partial d_{ij}} (y_i - y_j)</span>
<span id="cb5-1398"><a href="#cb5-1398" aria-hidden="true" tabindex="-1"></a>$$ {#eq-appendixa2}</span>
<span id="cb5-1399"><a href="#cb5-1399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1400"><a href="#cb5-1400" aria-hidden="true" tabindex="-1"></a>The gradient $\frac{\partial C}{\partial d_{ji}}$ is computed</span>
<span id="cb5-1401"><a href="#cb5-1401" aria-hidden="true" tabindex="-1"></a>from the definition of the Kullback-Leibler divergence in @eq-appendixa1</span>
<span id="cb5-1402"><a href="#cb5-1402" aria-hidden="true" tabindex="-1"></a>(note that he first part of this equation is a constant).</span>
<span id="cb5-1403"><a href="#cb5-1403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1404"><a href="#cb5-1404" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1405"><a href="#cb5-1405" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb5-1406"><a href="#cb5-1406" aria-hidden="true" tabindex="-1"></a>\frac{\partial C}{\partial d_{ij}} </span>
<span id="cb5-1407"><a href="#cb5-1407" aria-hidden="true" tabindex="-1"></a>&amp; = - \sum_{k\neq\ell} p_{k\ell} \frac{\partial \log q_{k\ell}}{\partial d_{ij}} <span class="sc">\\</span></span>
<span id="cb5-1408"><a href="#cb5-1408" aria-hidden="true" tabindex="-1"></a>&amp; = - \sum_{k\neq\ell} p_{k\ell} \frac{\partial \log q_{k\ell}Q - \log Z}{\partial d_{ij}} <span class="sc">\\</span></span>
<span id="cb5-1409"><a href="#cb5-1409" aria-hidden="true" tabindex="-1"></a>&amp; = - \sum_{k\neq\ell} p_{k\ell} \left(\frac{1}{q_{k\ell}Z} \frac{\partial ((1 - d_{k\ell}^2)^{-1})}{\partial d_{ij}} - \frac{1}{Z}\frac{\partial Z}{\partial d_{ij}} \right) ) </span>
<span id="cb5-1410"><a href="#cb5-1410" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb5-1411"><a href="#cb5-1411" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1412"><a href="#cb5-1412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1413"><a href="#cb5-1413" aria-hidden="true" tabindex="-1"></a>The gradient $\frac{\partial ((1 - d_{k\ell}^2)^{-1})}{\partial d_{ij}}$ is only onzero when $k=i$ and $\ell = j$. Hence, the gradient $\frac{\partial C}{\partial d_{ij}}$ is given by</span>
<span id="cb5-1414"><a href="#cb5-1414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1415"><a href="#cb5-1415" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1416"><a href="#cb5-1416" aria-hidden="true" tabindex="-1"></a>\frac{\partial C}{\partial d_{ij}} + 2 \frac{p{ij}}{q_{ij}Z} (1 = d_{ij}^2)^{-2} - 2 \sum_{k\neq \ell} p_{k\ell} \frac{(1+d_{ij}^2)^{-2}}{Z}.</span>
<span id="cb5-1417"><a href="#cb5-1417" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1418"><a href="#cb5-1418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1419"><a href="#cb5-1419" aria-hidden="true" tabindex="-1"></a>Noting that $\sum_{k\neq \ell} p_{k\ell} = 1$, we see that the gradients simplifies to</span>
<span id="cb5-1420"><a href="#cb5-1420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1421"><a href="#cb5-1421" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1422"><a href="#cb5-1422" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb5-1423"><a href="#cb5-1423" aria-hidden="true" tabindex="-1"></a>\frac{\partial C}{\partial d_{ij}} &amp; = 2 p{ij} (1 + d_{ij}^2)^{-1} - 2 q_{ij}(1 + d_{ij}^2)^{-1} <span class="sc">\\</span></span>
<span id="cb5-1424"><a href="#cb5-1424" aria-hidden="true" tabindex="-1"></a>&amp; = 2 (p{ij} - q_{ij}) (1 + d_{ij}^2)^{-1}.</span>
<span id="cb5-1425"><a href="#cb5-1425" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb5-1426"><a href="#cb5-1426" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1427"><a href="#cb5-1427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1428"><a href="#cb5-1428" aria-hidden="true" tabindex="-1"></a>Substituting this term into @eq-appendixa2, we obtain the gradient</span>
<span id="cb5-1429"><a href="#cb5-1429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1430"><a href="#cb5-1430" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1431"><a href="#cb5-1431" aria-hidden="true" tabindex="-1"></a>\frac{\partial C}{\partial y_i} = 4 \sum_j (p{ij} - q_{ij}) (1 + \|y_i - y_j\|^2)^{-1} (y_i - y_j).</span>
<span id="cb5-1432"><a href="#cb5-1432" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1433"><a href="#cb5-1433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1434"><a href="#cb5-1434" aria-hidden="true" tabindex="-1"></a><span class="fu"># Appendix B: Analytical Solution to Random Walk Probabilities {.appendix .unnumbered}</span></span>
<span id="cb5-1435"><a href="#cb5-1435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1436"><a href="#cb5-1436" aria-hidden="true" tabindex="-1"></a>Below, we describe the analytical solution to the random walk</span>
<span id="cb5-1437"><a href="#cb5-1437" aria-hidden="true" tabindex="-1"></a>probabilities that are employed in the random walk version of t-SNE</span>
<span id="cb5-1438"><a href="#cb5-1438" aria-hidden="true" tabindex="-1"></a>(@sec-large-data). The solution is described in more</span>
<span id="cb5-1439"><a href="#cb5-1439" aria-hidden="true" tabindex="-1"></a>detail @grady:random.</span>
<span id="cb5-1440"><a href="#cb5-1440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1441"><a href="#cb5-1441" aria-hidden="true" tabindex="-1"></a>It can be shown that computing the probability that a random walk</span>
<span id="cb5-1442"><a href="#cb5-1442" aria-hidden="true" tabindex="-1"></a>initiated from a non-landmark point (on a graph that is specified by</span>
<span id="cb5-1443"><a href="#cb5-1443" aria-hidden="true" tabindex="-1"></a>adjacency matrix W) first reaches a specific landmark point is equal</span>
<span id="cb5-1444"><a href="#cb5-1444" aria-hidden="true" tabindex="-1"></a>to computing the solution to the combinatorial Dirichlet problem in</span>
<span id="cb5-1445"><a href="#cb5-1445" aria-hidden="true" tabindex="-1"></a>which the boundary conditions are at the locations of the landmark</span>
<span id="cb5-1446"><a href="#cb5-1446" aria-hidden="true" tabindex="-1"></a>points, the considered landmark point is fixed to unity, and the other</span>
<span id="cb5-1447"><a href="#cb5-1447" aria-hidden="true" tabindex="-1"></a>landmarks points are set to zero @kakutani:dirichlet ;</span>
<span id="cb5-1448"><a href="#cb5-1448" aria-hidden="true" tabindex="-1"></a>@doyle:random.  In practice, the solution can thus be obtained</span>
<span id="cb5-1449"><a href="#cb5-1449" aria-hidden="true" tabindex="-1"></a>by minimizing the combinatorial formulation of the Dirichlet integral</span>
<span id="cb5-1450"><a href="#cb5-1450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1451"><a href="#cb5-1451" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1452"><a href="#cb5-1452" aria-hidden="true" tabindex="-1"></a>D<span class="co">[</span><span class="ot">x</span><span class="co">]</span> = \frac12 x^\top L x,</span>
<span id="cb5-1453"><a href="#cb5-1453" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1454"><a href="#cb5-1454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1455"><a href="#cb5-1455" aria-hidden="true" tabindex="-1"></a>where $L$ represents the graph Laplacian. Mathematically, the graph</span>
<span id="cb5-1456"><a href="#cb5-1456" aria-hidden="true" tabindex="-1"></a>Laplacian is given by $L = D−W$, where $D = \mathrm{diag} (\sum_j</span>
<span id="cb5-1457"><a href="#cb5-1457" aria-hidden="true" tabindex="-1"></a>w_{1j}, \sum_j w_{2j}, \dots, \sum_j w_{nj} )$. Without loss of</span>
<span id="cb5-1458"><a href="#cb5-1458" aria-hidden="true" tabindex="-1"></a>generality, we may reorder the landmark points such that the landmark</span>
<span id="cb5-1459"><a href="#cb5-1459" aria-hidden="true" tabindex="-1"></a>points come first. As a result, the combinatorial Dirichlet integral</span>
<span id="cb5-1460"><a href="#cb5-1460" aria-hidden="true" tabindex="-1"></a>decomposes into</span>
<span id="cb5-1461"><a href="#cb5-1461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1462"><a href="#cb5-1462" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1463"><a href="#cb5-1463" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb5-1464"><a href="#cb5-1464" aria-hidden="true" tabindex="-1"></a>D_{x_N} &amp; = \frac12 </span>
<span id="cb5-1465"><a href="#cb5-1465" aria-hidden="true" tabindex="-1"></a>\left[\begin{array}{cc}</span>
<span id="cb5-1466"><a href="#cb5-1466" aria-hidden="true" tabindex="-1"></a>x_L^\top &amp; x_N^\top \end{array}\right] \, </span>
<span id="cb5-1467"><a href="#cb5-1467" aria-hidden="true" tabindex="-1"></a>\left<span class="co">[</span><span class="ot">\begin{array}{cc}  L_L &amp; B \\ B^\top &amp; L_N \end{array}\right</span><span class="co">]</span> \, </span>
<span id="cb5-1468"><a href="#cb5-1468" aria-hidden="true" tabindex="-1"></a>\left[\begin{array}{c}</span>
<span id="cb5-1469"><a href="#cb5-1469" aria-hidden="true" tabindex="-1"></a>x_L <span class="sc">\\</span> x_N \end{array}\right] <span class="sc">\\</span></span>
<span id="cb5-1470"><a href="#cb5-1470" aria-hidden="true" tabindex="-1"></a>&amp; = \frac12 (x_L^\top L_L x_L + 2 x_N^\top B^\top x_L + x_N^\top L_N x_N),</span>
<span id="cb5-1471"><a href="#cb5-1471" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb5-1472"><a href="#cb5-1472" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1473"><a href="#cb5-1473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1474"><a href="#cb5-1474" aria-hidden="true" tabindex="-1"></a>where we use the subscript ${\cdot}_L$ to indicate the landmark points, and the</span>
<span id="cb5-1475"><a href="#cb5-1475" aria-hidden="true" tabindex="-1"></a>subscript ${\cdot}_N$ to indicate the non-landmark points. Differentiating</span>
<span id="cb5-1476"><a href="#cb5-1476" aria-hidden="true" tabindex="-1"></a>$D<span class="co">[</span><span class="ot">x_N</span><span class="co">]</span>$ with respect to $x_N$ and finding its critical points amounts to</span>
<span id="cb5-1477"><a href="#cb5-1477" aria-hidden="true" tabindex="-1"></a>solving the linear systems </span>
<span id="cb5-1478"><a href="#cb5-1478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1479"><a href="#cb5-1479" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb5-1480"><a href="#cb5-1480" aria-hidden="true" tabindex="-1"></a>L_N x_N = −B^\top.</span>
<span id="cb5-1481"><a href="#cb5-1481" aria-hidden="true" tabindex="-1"></a>$$ {#eq-appendixb1}</span>
<span id="cb5-1482"><a href="#cb5-1482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1483"><a href="#cb5-1483" aria-hidden="true" tabindex="-1"></a>Please note that in this linear system, $B^\top$ is a matrix</span>
<span id="cb5-1484"><a href="#cb5-1484" aria-hidden="true" tabindex="-1"></a>containing the columns from the graph Laplacian $L$ that correspond to</span>
<span id="cb5-1485"><a href="#cb5-1485" aria-hidden="true" tabindex="-1"></a>the landmark points (excluding the rows that correspond to landmark</span>
<span id="cb5-1486"><a href="#cb5-1486" aria-hidden="true" tabindex="-1"></a>points). After normalization of the solutions to the systems $X_N$,</span>
<span id="cb5-1487"><a href="#cb5-1487" aria-hidden="true" tabindex="-1"></a>the column vectors of $X_N$ contain the probability that a random walk</span>
<span id="cb5-1488"><a href="#cb5-1488" aria-hidden="true" tabindex="-1"></a>initiated from a non-landmark point terminates in a landmark</span>
<span id="cb5-1489"><a href="#cb5-1489" aria-hidden="true" tabindex="-1"></a>point. One should note that the linear system in </span>
<span id="cb5-1490"><a href="#cb5-1490" aria-hidden="true" tabindex="-1"></a>@eq-appendixb1 is only nonsingular if the graph is completely</span>
<span id="cb5-1491"><a href="#cb5-1491" aria-hidden="true" tabindex="-1"></a>connected, or if each connected component in the graph contains at</span>
<span id="cb5-1492"><a href="#cb5-1492" aria-hidden="true" tabindex="-1"></a>least one landmark point @biggs:algebraic.</span>
<span id="cb5-1493"><a href="#cb5-1493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-1494"><a href="#cb5-1494" aria-hidden="true" tabindex="-1"></a>Because we are interested in the probability of a random walk</span>
<span id="cb5-1495"><a href="#cb5-1495" aria-hidden="true" tabindex="-1"></a>initiated from a landmark point terminating at another landmark point,</span>
<span id="cb5-1496"><a href="#cb5-1496" aria-hidden="true" tabindex="-1"></a>we duplicate all landmark points in the neighborhood graph, and</span>
<span id="cb5-1497"><a href="#cb5-1497" aria-hidden="true" tabindex="-1"></a>initiate the random walks from the duplicate landmarks. Because of</span>
<span id="cb5-1498"><a href="#cb5-1498" aria-hidden="true" tabindex="-1"></a>memory constraints, it is not possible to store the entire matrix</span>
<span id="cb5-1499"><a href="#cb5-1499" aria-hidden="true" tabindex="-1"></a>$X_N$ into memory (note that we are only interested in a small number</span>
<span id="cb5-1500"><a href="#cb5-1500" aria-hidden="true" tabindex="-1"></a>of rows from this matrix, viz., in the rows corresponding to the</span>
<span id="cb5-1501"><a href="#cb5-1501" aria-hidden="true" tabindex="-1"></a>duplicate landmark points).  Hence, we solve the linear systems</span>
<span id="cb5-1502"><a href="#cb5-1502" aria-hidden="true" tabindex="-1"></a>defined by the columns of $−B^\top$ one-by-one, and store only the</span>
<span id="cb5-1503"><a href="#cb5-1503" aria-hidden="true" tabindex="-1"></a>parts of the solutions that correspond to the duplicate landmark</span>
<span id="cb5-1504"><a href="#cb5-1504" aria-hidden="true" tabindex="-1"></a>points. For computational reasons, we first perform a Cholesky</span>
<span id="cb5-1505"><a href="#cb5-1505" aria-hidden="true" tabindex="-1"></a>factorization of $L_N$, such that $L_N = C C^\top$, where $C$ is an</span>
<span id="cb5-1506"><a href="#cb5-1506" aria-hidden="true" tabindex="-1"></a>upper-triangular matrix. Subsequently, the solution to the linear</span>
<span id="cb5-1507"><a href="#cb5-1507" aria-hidden="true" tabindex="-1"></a>system in Equation @eq-appendixb1 is obtained by solving the</span>
<span id="cb5-1508"><a href="#cb5-1508" aria-hidden="true" tabindex="-1"></a>linear systems $Cy = −B^\top$ and $C x_N = y$ using a fast</span>
<span id="cb5-1509"><a href="#cb5-1509" aria-hidden="true" tabindex="-1"></a>backsubstitution method.</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<script>
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    let pseudocodeOptions = {
      indentSize: el.dataset.indentSize || "1.2em",
      commentDelimiter: el.dataset.commentDelimiter || "//",
      lineNumber: el.dataset.lineNumber === "true" ? true : false,
      lineNumberPunc: el.dataset.lineNumberPunc || ":",
      noEnd: el.dataset.noEnd === "true" ? true : false,
      titlePrefix: el.dataset.algTitle || "Algorithm"
    };
    pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
  });
})(document);
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
    titlePrefix = el.dataset.algTitle;
    titleIndex = el.dataset.chapterLevel ? el.dataset.chapterLevel + "." + el.dataset.pseudocodeIndex : el.dataset.pseudocodeIndex;
    titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
  });
})(document);
</script>




</body></html>